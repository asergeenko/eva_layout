#!/usr/bin/env python3
"""Test improved AUDI A6 (C7) 4 DXF search functionality."""

import os
import re

def test_audi_a6_search_v2():
    """Test the improved search for AUDI A6 (C7) 4 DXF files."""
    print("üöó –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —É–ª—É—á—à–µ–Ω–Ω–æ–≥–æ –ø–æ–∏—Å–∫–∞ DXF —Ñ–∞–π–ª–æ–≤ –¥–ª—è AUDI A6 (C7) 4")
    print("=" * 70)
    
    # Test data from Excel analysis
    article = "EVA_BORT+Audi+A6+2011-2018+black+12"
    product_name = "AUDI A6 (C7) 4"
    
    print(f"üìã –ê—Ä—Ç–∏–∫—É–ª: {article}")
    print(f"üè∑Ô∏è –¢–æ–≤–∞—Ä: {product_name}")
    print()
    
    # Simulate the improved search logic with best match selection
    def search_by_product_name_v2(product_name):
        """Improved search by product name logic with best match selection."""
        found_files = []
        
        # Extract brand and model from product name
        product_upper = product_name.upper()
        
        # Handle common brand name mappings
        brand_mapping = {'AUDI': 'AUDI'}
        
        # Find brand in product name
        detected_brand = None
        for brand_key, brand_folder in brand_mapping.items():
            if brand_key in product_upper:
                detected_brand = brand_folder
                break
        
        print(f"üîç –û–ø—Ä–µ–¥–µ–ª—ë–Ω –±—Ä–µ–Ω–¥: {detected_brand}")
        
        if detected_brand:
            brand_path = f"dxf_samples/{detected_brand}"
            if os.path.exists(brand_path):
                print(f"‚úÖ –ü–∞–ø–∫–∞ –±—Ä–µ–Ω–¥–∞ –Ω–∞–π–¥–µ–Ω–∞: {brand_path}")
                
                # Create search keywords from product name
                product_keywords = []
                
                # Clean product name and extract model parts
                model_part = product_upper.replace(detected_brand, '').strip()
                print(f"üìù –ú–æ–¥–µ–ª—å–Ω–∞—è —á–∞—Å—Ç—å: '{model_part}'")
                
                # Add full product name as keyword
                product_keywords.append(product_name.lower())
                
                # Handle parentheses and extract parts
                if '(' in model_part and ')' in model_part:
                    parentheses_content = re.findall(r'\((.*?)\)', model_part)
                    base_model = re.sub(r'\s*\([^)]*\)\s*', ' ', model_part).strip()
                    
                    print(f"üîñ –°–æ–¥–µ—Ä–∂–∏–º–æ–µ —Å–∫–æ–±–æ–∫: {parentheses_content}")
                    print(f"üîñ –ë–∞–∑–æ–≤–∞—è –º–æ–¥–µ–ª—å: '{base_model}'")
                    
                    product_keywords.extend([
                        base_model.lower(),
                        model_part.replace('(', '').replace(')', '').lower(),
                    ])
                    
                    for content in parentheses_content:
                        product_keywords.extend([
                            content.lower(),
                            f"{base_model} {content}".lower(),
                        ])
                
                # Extract individual parts
                model_parts = re.sub(r'[^\w\s]', ' ', model_part).split()
                product_keywords.extend([part.lower() for part in model_parts if len(part) > 1])
                
                # Remove duplicates
                product_keywords = list(set([k.strip() for k in product_keywords if k.strip()]))
                
                print(f"üîë –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞:")
                for kw in sorted(product_keywords):
                    print(f"   ‚Ä¢ '{kw}'")
                print()
                
                # Search through brand folders and find the best match
                best_match_folder = None
                best_match_score = 0
                all_folders_scores = []
                
                print(f"üìÅ –ü–æ–∏—Å–∫ –≤ –ø–∞–ø–∫–∞—Ö –±—Ä–µ–Ω–¥–∞:")
                
                for model_folder in os.listdir(brand_path):
                    model_folder_path = os.path.join(brand_path, model_folder)
                    if os.path.isdir(model_folder_path):
                        folder_name_lower = model_folder.lower()
                        
                        # Calculate match score with Cyrillic/Latin normalization
                        match_score = 0
                        matched_keywords = []
                        
                        # Normalize folder name for better matching (handle Cyrillic/Latin)
                        normalized_folder = folder_name_lower
                        # Replace common Cyrillic letters with Latin equivalents
                        cyrillic_to_latin = {
                            '–∞': 'a', '–ê': 'A',
                            '—Å': 'c', '–°': 'C',
                            '–µ': 'e', '–ï': 'E',
                            '–æ': 'o', '–û': 'O',
                            '—Ä': 'p', '–†': 'P',
                            '—Ö': 'x', '–•': 'X'
                        }
                        for cyrillic, latin in cyrillic_to_latin.items():
                            normalized_folder = normalized_folder.replace(cyrillic, latin)
                        
                        # Special bonus for exact generation match (e.g., "(c7)" in folder)
                        if '(' in model_part and ')' in model_part:
                            parentheses_content = re.findall(r'\((.*?)\)', model_part)
                            for content in parentheses_content:
                                # Check for exact parentheses match in folder
                                if f"({content.lower()})" in normalized_folder:
                                    match_score += 20  # High bonus for exact generation match
                                    matched_keywords.append(f"'({content.lower()})' —Ç–æ—á–Ω–æ–µ –ø–æ–∫–æ–ª–µ–Ω–∏–µ (+20)")
                                elif f"({content.lower()})" in folder_name_lower:
                                    match_score += 20
                                    matched_keywords.append(f"'({content.lower()})' —Ç–æ—á–Ω–æ–µ –ø–æ–∫–æ–ª–µ–Ω–∏–µ –∫–∏—Ä–∏–ª–ª–∏—Ü–∞ (+20)")
                        
                        for keyword in product_keywords:
                            if keyword and len(keyword) > 2:
                                # Direct match in normalized folder name
                                if keyword in normalized_folder:
                                    score_add = len(keyword) * 2
                                    match_score += score_add
                                    matched_keywords.append(f"'{keyword}' –≤ –Ω–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–æ–º (+{score_add})")
                                # Direct match in original folder name
                                elif keyword in folder_name_lower:
                                    score_add = len(keyword) * 2
                                    match_score += score_add
                                    matched_keywords.append(f"'{keyword}' (+{score_add})")
                                else:
                                    # Check partial matches in normalized folder
                                    keyword_parts = keyword.split()
                                    matched_parts = sum(1 for part in keyword_parts 
                                                      if part in normalized_folder or part in folder_name_lower)
                                    if matched_parts > 0:
                                        score_add = matched_parts * 3
                                        match_score += score_add
                                        matched_keywords.append(f"'{keyword}' —á–∞—Å—Ç–∏—á–Ω–æ (+{score_add})")
                        
                        all_folders_scores.append((model_folder, match_score))
                        
                        print(f"   üìÇ {model_folder}")
                        print(f"      –ù–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–æ–µ: '{normalized_folder}'")
                        print(f"      –û—Ü–µ–Ω–∫–∞: {match_score}")
                        if matched_keywords:
                            print(f"      –°–æ–≤–ø–∞–¥–µ–Ω–∏—è: {', '.join(matched_keywords)}")
                        
                        # Track the best match
                        if match_score > best_match_score and match_score >= 6:
                            best_match_score = match_score
                            best_match_folder = (model_folder, model_folder_path)
                        
                        print()
                
                # Sort by score to show ranking
                print(f"üèÜ –†–µ–π—Ç–∏–Ω–≥ –ø–∞–ø–æ–∫ –ø–æ –æ—Ü–µ–Ω–∫–µ:")
                sorted_scores = sorted(all_folders_scores, key=lambda x: x[1], reverse=True)
                for i, (folder, score) in enumerate(sorted_scores[:5], 1):
                    status = "üëë –í–´–ë–†–ê–ù–ê" if best_match_folder and folder == best_match_folder[0] else ""
                    print(f"   {i}. {folder}: {score} –±–∞–ª–ª–æ–≤ {status}")
                print()
                
                # Try to get DXF files from the best matching folder
                if best_match_folder:
                    model_folder, model_folder_path = best_match_folder
                    print(f"üéØ –í—ã–±—Ä–∞–Ω–∞ –ª—É—á—à–∞—è –ø–∞–ø–∫–∞: {model_folder} (–æ—Ü–µ–Ω–∫–∞: {best_match_score})")
                    
                    dxf_folder = os.path.join(model_folder_path, "DXF")
                    if os.path.exists(dxf_folder):
                        dxf_files_found = [f for f in os.listdir(dxf_folder) if f.lower().endswith('.dxf')]
                        print(f"üìÑ –ù–∞–π–¥–µ–Ω–æ DXF —Ñ–∞–π–ª–æ–≤: {len(dxf_files_found)}")
                        for dxf_file in dxf_files_found:
                            full_path = os.path.join(dxf_folder, dxf_file)
                            found_files.append(full_path)
                            print(f"   ‚Ä¢ {dxf_file}")
                    else:
                        # Check for DXF files directly in model folder
                        dxf_files_found = [f for f in os.listdir(model_folder_path) if f.lower().endswith('.dxf')]
                        if dxf_files_found:
                            print(f"üìÑ –ù–∞–π–¥–µ–Ω–æ DXF —Ñ–∞–π–ª–æ–≤ (–ø—Ä—è–º–æ –≤ –ø–∞–ø–∫–µ): {len(dxf_files_found)}")
                            for dxf_file in dxf_files_found:
                                full_path = os.path.join(model_folder_path, dxf_file)
                                found_files.append(full_path)
                                print(f"   ‚Ä¢ {dxf_file}")
                else:
                    print("‚ùå –ü–æ–¥—Ö–æ–¥—è—â–∏–µ –ø–∞–ø–∫–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã")
                    
            else:
                print(f"‚ùå –ü–∞–ø–∫–∞ –±—Ä–µ–Ω–¥–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞: {brand_path}")
        
        return found_files
    
    # Run the test
    found_files = search_by_product_name_v2(product_name)
    
    print(f"\nüìä –†–µ–∑—É–ª—å—Ç–∞—Ç –ø–æ–∏—Å–∫–∞:")
    if found_files:
        print(f"‚úÖ –ù–∞–π–¥–µ–Ω–æ {len(found_files)} DXF —Ñ–∞–π–ª–æ–≤:")
        for file_path in found_files:
            print(f"   üìÑ {file_path}")
    else:
        print("‚ùå DXF —Ñ–∞–π–ª—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã")
    
    print(f"\nüéØ –ó–∞–∫–ª—é—á–µ–Ω–∏–µ:")
    if found_files and "audi –∞6 (—Å7) 4" in found_files[0].lower():
        print("üéâ –û—Ç–ª–∏—á–Ω–æ! –ù–∞–π–¥–µ–Ω–∞ –ø—Ä–∞–≤–∏–ª—å–Ω–∞—è –ø–∞–ø–∫–∞ 'Audi –ê6 (–°7) 4'!")
        print("‚úÖ –£–ª—É—á—à–µ–Ω–Ω—ã–π –∞–ª–≥–æ—Ä–∏—Ç–º —Ä–∞–±–æ—Ç–∞–µ—Ç –∏–¥–µ–∞–ª—å–Ω–æ!")
    elif found_files:
        print("‚ö†Ô∏è –ù–∞–π–¥–µ–Ω—ã —Ñ–∞–π–ª—ã, –Ω–æ –≤–æ–∑–º–æ–∂–Ω–æ –Ω–µ –∏–∑ –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ–π –ø–∞–ø–∫–∏")
        print("üîß –¢—Ä–µ–±—É–µ—Ç—Å—è –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∞ –æ—Ü–µ–Ω–∫–∏")
    else:
        print("‚ùå –¢—Ä–µ–±—É–µ—Ç—Å—è –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∞ –∞–ª–≥–æ—Ä–∏—Ç–º–∞ –ø–æ–∏—Å–∫–∞")
    
    return len(found_files) > 0

if __name__ == "__main__":
    success = test_audi_a6_search_v2()
    print(f"\n{'üéâ –¢–µ—Å—Ç –ø—Ä–æ–π–¥–µ–Ω!' if success else '‚ùå –¢–µ—Å—Ç –Ω–µ –ø—Ä–æ–π–¥–µ–Ω!'}")