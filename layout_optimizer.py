"""Helper functions for EVA mat nesting optimization."""

# Version for cache busting
__version__ = "1.5.0"

import numpy as np
import time

from shapely.geometry import Polygon, Point
import logging

from carpet import Carpet, PlacedCarpet, UnplacedCarpet, PlacedSheet
from geometry_utils import translate_polygon, rotate_polygon
from fast_geometry import (
    SpatialIndexCache,
    check_collision_fast_indexed_intersects_only,
    batch_check_collisions_cached_fast,
)

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logger = logging.getLogger(__name__)

# OPTIMIZATION: Global STRtree cache for fast collision detection
_global_spatial_cache = SpatialIndexCache()

logging.getLogger("ezdxf").setLevel(logging.ERROR)

__all__ = [
    "rotate_polygon",
    "translate_polygon",
    "place_polygon_at_origin",
    "check_collision",
    "bin_packing_with_inventory",
    "calculate_usage_percent",
    "bin_packing",
]

# –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –∫—ç—à–∏ –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –ø–æ–≤–æ—Ä–æ—Ç–æ–≤ –∫–æ–≤—Ä–æ–≤
_rotation_cache: dict[
    int, dict[int, Polygon]
] = {}  # carpet_id -> {angle: rotated_polygon}
_original_polygons: dict[int, Polygon] = {}  # carpet_id -> original_polygon


def clear_optimization_caches():
    """–û—á–∏—Å—Ç–∏—Ç—å –≤—Å–µ –∫—ç—à–∏ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏."""
    global _rotation_cache, _original_polygons, _trapped_space_cache, _spatial_index
    _rotation_cache.clear()
    _original_polygons.clear()


def cache_original_polygons(carpets: list[Carpet]) -> None:
    """–ö—ç—à–∏—Ä–æ–≤–∞—Ç—å –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–µ –ø–æ–ª–∏–≥–æ–Ω—ã –î–û –ª—é–±—ã—Ö —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–π."""
    logger.info(
        f"üèÅ –ù–∞—á–∏–Ω–∞–µ–º –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã—Ö –ø–æ–ª–∏–≥–æ–Ω–æ–≤ –¥–ª—è {len(carpets)} –∫–æ–≤—Ä–æ–≤"
    )
    for carpet in carpets:
        carpet_id = carpet.carpet_id
        if carpet_id not in _original_polygons:
            # –°–æ–∑–¥–∞–µ–º –∫–æ–ø–∏—é –ø–æ–ª–∏–≥–æ–Ω–∞, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –ø—Ä–æ–±–ª–µ–º —Å–æ —Å—Å—ã–ª–∫–∞–º–∏
            _original_polygons[carpet_id] = Polygon(carpet.polygon.exterior.coords)


def get_original_polygon(carpet_id: int) -> Polygon | None:
    if carpet_id in _original_polygons:
        return _original_polygons[carpet_id]
    return None


def get_cached_rotation(
    carpet: Carpet | PlacedCarpet | UnplacedCarpet, angle: int
) -> Polygon:
    """–ü–æ–ª—É—á–∏—Ç—å –∫—ç—à–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ø–æ–≤–æ—Ä–æ—Ç –ø–æ–ª–∏–≥–æ–Ω–∞ –æ—Ç –û–†–ò–ì–ò–ù–ê–õ–¨–ù–û–ô –≥–µ–æ–º–µ—Ç—Ä–∏–∏."""
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —É –Ω–∞—Å –µ—Å—Ç—å –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π –ø–æ–ª–∏–≥–æ–Ω
    carpet_id = carpet.carpet_id
    if carpet_id not in _original_polygons:
        # –û–®–ò–ë–ö–ê: –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π –ø–æ–ª–∏–≥–æ–Ω –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –∑–∞–∫—ç—à–∏—Ä–æ–≤–∞–Ω –∑–∞—Ä–∞–Ω–µ–µ!
        logger.warning(f"‚ùå –û—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π –ø–æ–ª–∏–≥–æ–Ω –¥–ª—è carpet={carpet} –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –∫—ç—à–µ!")
        # Fallback: –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ç–µ–∫—É—â–∏–π –ø–æ–ª–∏–≥–æ–Ω (–º–æ–∂–µ—Ç –±—ã—Ç—å —É–∂–µ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–Ω—ã–º)
        _original_polygons[carpet_id] = Polygon(carpet.polygon.exterior.coords)

    if carpet not in _rotation_cache:
        _rotation_cache[carpet_id] = {}

    if angle not in _rotation_cache[carpet_id]:
        # –í—ã—á–∏—Å–ª—è–µ–º –ø–æ–≤–æ—Ä–æ—Ç –æ—Ç –û–†–ò–ì–ò–ù–ê–õ–¨–ù–û–ì–û –ø–æ–ª–∏–≥–æ–Ω–∞
        original_polygon = _original_polygons[carpet_id]
        rotated = (
            rotate_polygon(original_polygon, angle) if angle != 0 else original_polygon
        )
        _rotation_cache[carpet_id][angle] = rotated

    return _rotation_cache[carpet_id][angle]


def calculate_optimal_rotation_angles(
    polygon: Polygon, angle_step: int = 5
) -> list[float]:
    """
    üéØ –û–ü–¢–ò–ú–ê–õ–¨–ù–´–ï –£–ì–õ–´ –ü–û–í–û–†–û–¢–ê: –í—ã—á–∏—Å–ª—è–µ—Ç —É–≥–ª—ã, –∫–æ—Ç–æ—Ä—ã–µ –º–∞–∫—Å–∏–º–∏–∑–∏—Ä—É—é—Ç –ø–ª–æ—Ç–Ω–æ—Å—Ç—å —É–ø–∞–∫–æ–≤–∫–∏.

    –°—Ç—Ä–∞—Ç–µ–≥–∏—è:
    1. –ù–∞—Ö–æ–¥–∏—Ç –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞—é—â–∏–π –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫ (minimum bounding rectangle)
    2. –û–ø—Ä–µ–¥–µ–ª—è–µ—Ç —É–≥–æ–ª –Ω–∞–∫–ª–æ–Ω–∞ —ç—Ç–æ–≥–æ –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫–∞
    3. –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ü–†–ò–û–†–ò–¢–ï–¢–ù–´–ï —É–≥–ª—ã: —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ + –æ–ø—Ç–∏–º–∞–ª—å–Ω—ã–µ –¥–ª—è —Ñ–æ—Ä–º—ã

    Args:
        polygon: Shapely Polygon –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞
        angle_step: –®–∞–≥ —É–≥–ª–æ–≤ –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 5¬∞)

    Returns:
        –°–ø–∏—Å–æ–∫ –æ–ø—Ç–∏–º–∞–ª—å–Ω—ã—Ö —É–≥–ª–æ–≤ –ø–æ–≤–æ—Ä–æ—Ç–∞, –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –ø–æ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç—É
    """
    from shapely import minimum_rotated_rectangle
    import math

    # –ü–æ–ª—É—á–∞–µ–º –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞—é—â–∏–π –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫
    min_rect = minimum_rotated_rectangle(polygon)

    # –ò–∑–≤–ª–µ–∫–∞–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —É–≥–ª–æ–≤ –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫–∞
    coords = list(min_rect.exterior.coords)

    # –í—ã—á–∏—Å–ª—è–µ–º —É–≥–æ–ª –Ω–∞–∫–ª–æ–Ω–∞ –ø–µ—Ä–≤–æ–π —Å—Ç–æ—Ä–æ–Ω—ã –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫–∞
    dx = coords[1][0] - coords[0][0]
    dy = coords[1][1] - coords[0][1]
    angle_rad = math.atan2(dy, dx)
    angle_deg = math.degrees(angle_rad)

    # –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º —É–≥–æ–ª –∫ –¥–∏–∞–ø–∞–∑–æ–Ω—É [0, 90) —Ç–∞–∫ –∫–∞–∫ –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫ —Å–∏–º–º–µ—Ç—Ä–∏—á–µ–Ω
    angle_deg = angle_deg % 90

    # –ü–†–ò–û–†–ò–¢–ï–¢–ù–ê–Ø –°–¢–†–ê–¢–ï–ì–ò–Ø: –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —É–≥–ª–æ–≤ –¥–ª—è —Å–∫–æ—Ä–æ—Å—Ç–∏
    angles = []

    # 1. –í–´–°–û–ö–ò–ô –ü–†–ò–û–†–ò–¢–ï–¢: –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ —É–≥–ª—ã (0¬∞, 90¬∞, 180¬∞, 270¬∞)
    standard_angles = [0, 90, 180, 270]
    angles.extend(standard_angles)

    # 2. –í–´–°–û–ö–ò–ô –ü–†–ò–û–†–ò–¢–ï–¢: –û–ø—Ç–∏–º–∞–ª—å–Ω—ã–µ —É–≥–ª—ã –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ñ–æ—Ä–º—ã –∫–æ–≤—Ä–∞
    optimal_angle_1 = -angle_deg  # –ü–æ–≤–æ—Ä–æ—Ç –¥–ª—è –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏—è –ø–æ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª–∏
    optimal_angle_2 = 90 - angle_deg  # –ü–æ–≤–æ—Ä–æ—Ç –¥–ª—è –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏—è –ø–æ –≤–µ—Ä—Ç–∏–∫–∞–ª–∏

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–∞—Å–∫–æ–ª—å–∫–æ –æ–ø—Ç–∏–º–∞–ª—å–Ω—ã–µ —É–≥–ª—ã –æ—Ç–ª–∏—á–∞—é—Ç—Å—è –æ—Ç —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã—Ö
    # –ï—Å–ª–∏ –æ—Ç–ª–∏—á–∏–µ –º–µ–Ω—å—à–µ 3¬∞, –Ω–µ –¥–æ–±–∞–≤–ª—è–µ–º (–∏–∑–±—ã—Ç–æ—á–Ω–æ)
    for opt_angle in [optimal_angle_1, optimal_angle_2]:
        norm_angle = opt_angle % 360
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —Å–ª–∏—à–∫–æ–º –ª–∏ –±–ª–∏–∑–∫–æ –∫ —É–∂–µ –¥–æ–±–∞–≤–ª–µ–Ω–Ω—ã–º —É–≥–ª–∞–º
        is_unique = all(
            abs(norm_angle - existing) > 3 and abs(norm_angle - existing - 360) > 3
            for existing in angles
        )
        if (
            is_unique and abs(angle_deg) > 3
        ):  # –¢–æ–ª—å–∫–æ –µ—Å–ª–∏ —Ñ–æ—Ä–º–∞ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ –Ω–∞–∫–ª–æ–Ω–µ–Ω–∞
            angles.append(norm_angle)
            # –î–æ–±–∞–≤–ª—è–µ–º —ç—Ç–∏ —É–≥–ª—ã —Å–æ –≤—Å–µ—Ö 4 —Å—Ç–æ—Ä–æ–Ω
            for base_rotation in [0, 90, 180, 270]:
                rotated = (norm_angle + base_rotation) % 360
                if all(abs(rotated - existing) > 3 for existing in angles):
                    angles.append(rotated)

    # 3. –°–†–ï–î–ù–ò–ô –ü–†–ò–û–†–ò–¢–ï–¢: –ù–µ–±–æ–ª—å—à–∏–µ –≤–∞—Ä–∏–∞—Ü–∏–∏ –æ–ø—Ç–∏–º–∞–ª—å–Ω—ã—Ö —É–≥–ª–æ–≤
    # –¢–æ–ª—å–∫–æ –µ—Å–ª–∏ —Ñ–æ—Ä–º–∞ –∑–Ω–∞—á–∏—Ç–µ–ª—å–Ω–æ –Ω–∞–∫–ª–æ–Ω–µ–Ω–∞ (> 10¬∞)
    if abs(angle_deg) > 10:
        for base in [optimal_angle_1, optimal_angle_2]:
            for delta in [-angle_step, angle_step]:
                varied_angle = (base + delta) % 360
                if all(abs(varied_angle - existing) > 3 for existing in angles):
                    angles.append(varied_angle)

    # 4. –ù–ò–ó–ö–ò–ô –ü–†–ò–û–†–ò–¢–ï–¢: –ü—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã–µ —É–≥–ª—ã (—Ç–æ–ª—å–∫–æ –¥–ª—è –æ—á–µ–Ω—å –Ω–µ—Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã—Ö —Ñ–æ—Ä–º)
    # –î–æ–±–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —Ñ–æ—Ä–º–∞ –û–ß–ï–ù–¨ –Ω–∞–∫–ª–æ–Ω–µ–Ω–∞ (> 20¬∞) –∏ –æ—Ç–ª–∏—á–∞–µ—Ç—Å—è –æ—Ç —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π
    if abs(angle_deg) > 20:
        # –î–æ–±–∞–≤–ª—è–µ–º —É–≥–ª—ã —Å —à–∞–≥–æ–º 15¬∞ –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ ¬±30¬∞ –æ—Ç –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ–≥–æ
        for opt_angle in [optimal_angle_1, optimal_angle_2]:
            for additional_angle in range(-30, 31, 15):
                test_angle = (opt_angle + additional_angle) % 360
                if all(abs(test_angle - existing) > 3 for existing in angles):
                    angles.append(test_angle)

    # –£–±–∏—Ä–∞–µ–º –¥—É–±–ª–∏–∫–∞—Ç—ã –∏ —Å–æ—Ä—Ç–∏—Ä—É–µ–º
    # –í–ê–ñ–ù–û: –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç - —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ —É–≥–ª—ã –∏–¥—É—Ç –ø–µ—Ä–≤—ã–º–∏
    angles = sorted(set(round(a, 1) for a in angles))

    # –ü–µ—Ä–µ—É–ø–æ—Ä—è–¥–æ—á–∏–≤–∞–µ–º: —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ —É–≥–ª—ã (0,90,180,270) –≤ –Ω–∞—á–∞–ª–æ
    standard_set = set(standard_angles)
    priority_angles = [a for a in angles if a in standard_set]
    other_angles = [a for a in angles if a not in standard_set]

    return priority_angles + other_angles


def analyze_edge_straightness(polygon: Polygon) -> dict:
    """
    üìè –ê–ù–ê–õ–ò–ó –ü–†–Ø–ú–û–õ–ò–ù–ï–ô–ù–û–°–¢–ò –ö–†–ê–Å–í: –û–ø—Ä–µ–¥–µ–ª—è–µ—Ç, –∫–∞–∫–∏–µ –∫—Ä–∞—è –∫–æ–≤—Ä–∞ –Ω–∞–∏–±–æ–ª–µ–µ –ø—Ä—è–º—ã–µ.

    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ª–æ–≤–∞—Ä—å —Å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π –æ –∫—Ä–∞—è—Ö:
    - straightest_edge_angle: —É–≥–æ–ª –Ω–∞–∏–±–æ–ª–µ–µ –ø—Ä—è–º–æ–≥–æ –∫—Ä–∞—è
    - straightness_score: –æ—Ü–µ–Ω–∫–∞ –ø—Ä—è–º–æ–ª–∏–Ω–µ–π–Ω–æ—Å—Ç–∏ (0-1, –≥–¥–µ 1 = –∏–¥–µ–∞–ª—å–Ω–æ –ø—Ä—è–º–æ–π)
    """
    import math

    coords = list(polygon.exterior.coords)
    if len(coords) < 3:
        return {"straightest_edge_angle": 0, "straightness_score": 0}

    # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –∫–∞–∂–¥—ã–π –∫—Ä–∞–π –ø–æ–ª–∏–≥–æ–Ω–∞
    edge_info = []

    for i in range(len(coords) - 1):
        p1 = coords[i]
        p2 = coords[i + 1]

        # –î–ª–∏–Ω–∞ –∫—Ä–∞—è
        dx = p2[0] - p1[0]
        dy = p2[1] - p1[1]
        length = math.sqrt(dx * dx + dy * dy)

        if length < 1:  # –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –æ—á–µ–Ω—å –∫–æ—Ä–æ—Ç–∫–∏–µ –∫—Ä–∞—è
            continue

        # –£–≥–æ–ª –∫—Ä–∞—è
        angle = math.degrees(math.atan2(dy, dx))

        edge_info.append({"length": length, "angle": angle, "start": p1, "end": p2})

    if not edge_info:
        return {"straightest_edge_angle": 0, "straightness_score": 0}

    # –ù–∞—Ö–æ–¥–∏–º —Å–∞–º—ã–π –¥–ª–∏–Ω–Ω—ã–π –∫—Ä–∞–π (–æ–±—ã—á–Ω–æ –æ–Ω –Ω–∞–∏–±–æ–ª–µ–µ –≤–∞–∂–µ–Ω –¥–ª—è —Å—Ç—ã–∫–æ–≤–∫–∏)
    longest_edge = max(edge_info, key=lambda e: e["length"])

    # –û—Ü–µ–Ω–∫–∞ –ø—Ä—è–º–æ–ª–∏–Ω–µ–π–Ω–æ—Å—Ç–∏ = –æ—Ç–Ω–æ—à–µ–Ω–∏–µ –¥–ª–∏–Ω—ã –∫ –ø–µ—Ä–∏–º–µ—Ç—Ä—É
    straightness = longest_edge["length"] / polygon.length

    return {
        "straightest_edge_angle": longest_edge["angle"],
        "straightness_score": straightness,
        "longest_edge_length": longest_edge["length"],
    }


def apply_tetris_gravity(
    placed_carpets: list[PlacedCarpet], sheet_width_mm: float, sheet_height_mm: float
) -> list[PlacedCarpet]:
    """
    –ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ô –¢–ï–¢–†–ò–°-–î–í–ò–ñ–û–ö: –ü—Ä–∏–º–µ–Ω—è–µ—Ç –≥—Ä–∞–≤–∏—Ç–∞—Ü–∏—é –æ—Å—Ç–æ—Ä–æ–∂–Ω–æ, –Ω–µ –ª–æ–º–∞—è —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–µ —Ä–∞–∑–º–µ—â–µ–Ω–∏–µ.
    –ö–æ–≤—Ä—ã –ø–∞–¥–∞—é—Ç –≤–Ω–∏–∑ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —ç—Ç–æ –±–µ–∑–æ–ø–∞—Å–Ω–æ –∏ —É–ª—É—á—à–∞–µ—Ç —Ä–∞–∑–º–µ—â–µ–Ω–∏–µ.
    """
    if not placed_carpets or len(placed_carpets) < 2:
        return placed_carpets

    # –°–æ–∑–¥–∞–µ–º –∫–æ–ø–∏–∏ –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
    gravity_carpets = []
    for carpet in placed_carpets:
        gravity_carpets.append(
            PlacedCarpet(
                polygon=carpet.polygon,
                x_offset=carpet.x_offset,
                y_offset=carpet.y_offset,
                angle=carpet.angle,
                filename=carpet.filename,
                color=carpet.color,
                order_id=carpet.order_id,
                carpet_id=carpet.carpet_id,
                priority=carpet.priority,
            )
        )

    # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –≤—ã—Å–æ—Ç–µ (—Å–≤–µ—Ä—Ö—É –≤–Ω–∏–∑) - –≤–µ—Ä—Ö–Ω–∏–µ –∫–æ–≤—Ä—ã –ø—ã—Ç–∞–µ–º—Å—è –æ–ø—É—Å—Ç–∏—Ç—å
    gravity_carpets.sort(
        key=lambda c: c.polygon.bounds[3], reverse=True
    )  # –ü–æ –≤–µ—Ä—Ö–Ω–µ–º—É –∫—Ä–∞—é

    movements_made = 0
    max_movements = len(gravity_carpets) // 2

    # –ü—Ä–∏–º–µ–Ω—è–µ–º –≥—Ä–∞–≤–∏—Ç–∞—Ü–∏—é –æ—Å—Ç–æ—Ä–æ–∂–Ω–æ –∫ –≤–µ—Ä—Ö–Ω–∏–º –∫–æ–≤—Ä–∞–º
    for i, carpet in enumerate(gravity_carpets):
        if movements_made >= max_movements:
            break

        # –ü—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è = –≤—Å–µ –æ—Å—Ç–∞–ª—å–Ω—ã–µ –∫–æ–≤—Ä—ã (–Ω–µ –æ–±–Ω–æ–≤–ª—è–µ–º –≤ –ø—Ä–æ—Ü–µ—Å—Å–µ)
        obstacles = [other.polygon for j, other in enumerate(gravity_carpets) if j != i]

        # –¢–µ–∫—É—â–∏–µ –≥—Ä–∞–Ω–∏—Ü—ã –∫–æ–≤—Ä–∞
        current_bounds = carpet.polygon.bounds
        current_y = current_bounds[1]

        # –ö–û–ù–°–ï–†–í–ê–¢–ò–í–ù–ê–Ø –ì–†–ê–í–ò–¢–ê–¶–ò–Ø: –ø—Ä–æ–±—É–µ–º —Ç–æ–ª—å–∫–æ –Ω–µ–±–æ–ª—å—à–∏–µ —É–ª—É—á—à–µ–Ω–∏—è
        best_y = current_y
        improvement_found = False

        # –ü—Ä–æ–±—É–µ–º –æ–ø—É—Å—Ç–∏—Ç—å—Å—è –º–∞–∫—Å–∏–º—É–º –Ω–∞ 50–º–º –∑–∞ —Ä–∞–∑
        max_drop = min(50, current_y)  # –ù–µ –±–æ–ª—å—à–µ 5—Å–º –∏ –Ω–µ –Ω–∏–∂–µ 0

        for drop_distance in [5, 10, 15, 20, 25, 30, 40, 50]:
            if drop_distance > max_drop:
                break

            test_y = current_y - drop_distance
            if test_y < 0:
                continue

            # –°–æ–∑–¥–∞–µ–º —Ç–µ—Å—Ç–æ–≤—É—é –ø–æ–∑–∏—Ü–∏—é
            y_offset_change = test_y - current_bounds[1]
            test_polygon = translate_polygon(carpet.polygon, 0, y_offset_change)

            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –≥—Ä–∞–Ω–∏—Ü—ã –ª–∏—Å—Ç–∞
            test_bounds = test_polygon.bounds
            if test_bounds[1] < -1 or test_bounds[3] > sheet_height_mm + 1:
                continue

            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–ª–ª–∏–∑–∏–∏ —Å –¥—Ä—É–≥–∏–º–∏ –∫–æ–≤—Ä–∞–º–∏
            collision = False
            for obstacle in obstacles:
                if test_polygon.intersects(obstacle):
                    intersection = test_polygon.intersection(obstacle)
                    if intersection.area > 50:  # –ë–æ–ª–µ–µ –∫–æ–Ω—Å–µ—Ä–≤–∞—Ç–∏–≤–Ω—ã–π –ø–æ—Ä–æ–≥
                        collision = True
                        break

            if not collision:
                best_y = test_y
                improvement_found = True
            else:
                break  # –í—Å—Ç—Ä–µ—Ç–∏–ª–∏ –∫–æ–ª–ª–∏–∑–∏—é, –¥–∞–ª—å—à–µ –Ω–µ –ø—Ä–æ–±—É–µ–º

        # –ü—Ä–∏–º–µ–Ω—è–µ–º —É–ª—É—á—à–µ–Ω–∏–µ –µ—Å–ª–∏ –Ω–∞–π–¥–µ–Ω–æ
        if improvement_found and best_y < current_y - 3:  # –ú–∏–Ω–∏–º—É–º 3–º–º —É–ª—É—á—à–µ–Ω–∏—è
            y_offset_change = best_y - current_bounds[1]
            carpet.polygon = translate_polygon(carpet.polygon, 0, y_offset_change)
            carpet.y_offset += y_offset_change
            movements_made += 1

    return gravity_carpets


def apply_aggressive_gravity(
    placed_carpets: list[PlacedCarpet],
    sheet_width_mm: float,
    sheet_height_mm: float,
    max_iterations: int = 10,
) -> list[PlacedCarpet]:
    """
    üéØ –ê–ì–†–ï–°–°–ò–í–ù–ê–Ø –ì–†–ê–í–ò–¢–ê–¶–ò–Ø: –û–ø—É—Å–∫–∞–µ—Ç –í–°–ï –∫–æ–≤—Ä—ã –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –≤–Ω–∏–∑.

    –°—Ç—Ä–∞—Ç–µ–≥–∏—è:
    1. –°–æ—Ä—Ç–∏—Ä—É–µ—Ç –∫–æ–≤—Ä—ã —Å–Ω–∏–∑—É –≤–≤–µ—Ä—Ö (–Ω–∏–∂–Ω–∏–µ –Ω–µ –¥–≤–∏–≥–∞—é—Ç—Å—è, –≤–µ—Ä—Ö–Ω–∏–µ –ø–∞–¥–∞—é—Ç)
    2. –î–ª—è –∫–∞–∂–¥–æ–≥–æ –∫–æ–≤—Ä–∞ –Ω–∞—Ö–æ–¥–∏—Ç —Å–∞–º—É—é –Ω–∏–∑–∫—É—é –≤–æ–∑–º–æ–∂–Ω—É—é –ø–æ–∑–∏—Ü–∏—é
    3. –ü–æ–≤—Ç–æ—Ä—è–µ—Ç –Ω–µ—Å–∫–æ–ª—å–∫–æ –∏—Ç–µ—Ä–∞—Ü–∏–π –¥–ª—è –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–π –ø–ª–æ—Ç–Ω–æ—Å—Ç–∏

    Args:
        placed_carpets: –†–∞–∑–º–µ—â—ë–Ω–Ω—ã–µ –∫–æ–≤—Ä—ã
        sheet_width_mm: –®–∏—Ä–∏–Ω–∞ –ª–∏—Å—Ç–∞
        sheet_height_mm: –í—ã—Å–æ—Ç–∞ –ª–∏—Å—Ç–∞
        max_iterations: –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∏—Ç–µ—Ä–∞—Ü–∏–π

    Returns:
        –ö–æ–≤—Ä—ã –ø–æ—Å–ª–µ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è –≥—Ä–∞–≤–∏—Ç–∞—Ü–∏–∏
    """
    if not placed_carpets:
        return placed_carpets

    # –°–æ–∑–¥–∞–µ–º –∫–æ–ø–∏–∏
    result = []
    for carpet in placed_carpets:
        result.append(
            PlacedCarpet(
                polygon=carpet.polygon,
                x_offset=carpet.x_offset,
                y_offset=carpet.y_offset,
                angle=carpet.angle,
                filename=carpet.filename,
                color=carpet.color,
                order_id=carpet.order_id,
                carpet_id=carpet.carpet_id,
                priority=carpet.priority,
            )
        )

    # –ò—Ç–µ—Ä–∞—Ç–∏–≤–Ω–æ –ø—Ä–∏–º–µ–Ω—è–µ–º –≥—Ä–∞–≤–∏—Ç–∞—Ü–∏—é
    for iteration in range(max_iterations):
        any_movement = False
        logger.info(
            f"   –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–∞—è –≥—Ä–∞–≤–∏—Ç–∞—Ü–∏—è - –∏—Ç–µ—Ä–∞—Ü–∏—è {iteration + 1}/{max_iterations}"
        )

        # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ Y (—Å–Ω–∏–∑—É –≤–≤–µ—Ä—Ö) - –Ω–∏–∂–Ω–∏–µ —Å–Ω–∞—á–∞–ª–∞, –æ–Ω–∏ —Å—Ç–∞–±–∏–ª—å–Ω—ã
        result.sort(key=lambda c: c.polygon.bounds[1])

        # –ü—ã—Ç–∞–µ–º—Å—è –æ–ø—É—Å—Ç–∏—Ç—å –∫–∞–∂–¥—ã–π –∫–æ–≤—ë—Ä
        for i, carpet in enumerate(result):
            current_bounds = carpet.polygon.bounds
            current_bottom_y = current_bounds[1]

            # –ï—Å–ª–∏ —É–∂–µ –Ω–∞ –¥–Ω–µ, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º
            if current_bottom_y < 1:
                logger.debug(f"     –ö–æ–≤—ë—Ä {i} —É–∂–µ –Ω–∞ –¥–Ω–µ (Y={current_bottom_y:.1f})")
                continue

            # –ü—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è = –≤—Å–µ –æ—Å—Ç–∞–ª—å–Ω—ã–µ –∫–æ–≤—Ä—ã
            obstacles = [other.polygon for j, other in enumerate(result) if j != i]

            # –ò—â–µ–º —Å–∞–º—É—é –Ω–∏–∑–∫—É—é –ø–æ–∑–∏—Ü–∏—é –±–µ–∑ –∫–æ–ª–ª–∏–∑–∏–π
            # –ù–∞—á–∏–Ω–∞–µ–º —Å Y=0 –∏ –¥–≤–∏–≥–∞–µ–º—Å—è –≤–≤–µ—Ä—Ö, –ø–æ–∫–∞ –Ω–µ –Ω–∞–π–¥—ë–º —Å–≤–æ–±–æ–¥–Ω–æ–µ –º–µ—Å—Ç–æ
            best_y = current_bottom_y

            # –ü–†–ê–í–ò–õ–¨–ù–ê–Ø –°–¢–†–ê–¢–ï–ì–ò–Ø: –ò—â–µ–º –°–ê–ú–£–Æ –ù–ò–ó–ö–£–Æ –ø–æ–∑–∏—Ü–∏—é
            # –ù–∞—á–∏–Ω–∞–µ–º —Å —Ç–µ–∫—É—â–µ–π –ø–æ–∑–∏—Ü–∏–∏ –∏ –¥–≤–∏–≥–∞–µ–º—Å—è –í–ù–ò–ó, –ø–æ–∫–∞ –Ω–µ –Ω–∞–π–¥—ë–º –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–µ
            # –ü–æ—Å–ª–µ–¥–Ω—è—è –ø–æ–∑–∏—Ü–∏—è –±–µ–∑ –∫–æ–ª–ª–∏–∑–∏–∏ = —Å–∞–º–∞—è –Ω–∏–∑–∫–∞—è –≤–æ–∑–º–æ–∂–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è

            # –®–∞–≥ 1: –ì—Ä—É–±—ã–π –ø–æ–∏—Å–∫ —Å–≤–µ—Ä—Ö—É –≤–Ω–∏–∑ (—à–∞–≥ 5–º–º –¥–ª—è –±–∞–ª–∞–Ω—Å–∞ —Å–∫–æ—Ä–æ—Å—Ç–∏ –∏ —Ç–æ—á–Ω–æ—Å—Ç–∏)
            coarse_step = 5
            best_y = current_bottom_y

            # –ò–¥—ë–º –æ—Ç —Ç–µ–∫—É—â–µ–π –ø–æ–∑–∏—Ü–∏–∏ –≤–Ω–∏–∑ –¥–æ Y=0
            for test_y in range(int(current_bottom_y), -1, -coarse_step):
                y_shift = test_y - current_bounds[1]
                test_polygon = translate_polygon(carpet.polygon, 0, y_shift)

                test_bounds = test_polygon.bounds
                if test_bounds[1] < -0.1 or test_bounds[3] > sheet_height_mm + 0.1:
                    break  # –í—ã—à–ª–∏ –∑–∞ –≥—Ä–∞–Ω–∏—Ü—ã –ª–∏—Å—Ç–∞

                has_collision = False
                for obstacle in obstacles:
                    if check_collision(test_polygon, obstacle, min_gap=10.0):
                        has_collision = True
                        break

                if not has_collision:
                    # –≠—Ç–∞ –ø–æ–∑–∏—Ü–∏—è –≤–∞–ª–∏–¥–Ω–∞, –∑–∞–ø–æ–º–∏–Ω–∞–µ–º –∏ –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º —Å–ø—É—Å–∫–∞—Ç—å—Å—è
                    best_y = test_y
                else:
                    # –ù–∞—à–ª–∏ –∫–æ–ª–ª–∏–∑–∏—é, –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º—Å—è (–ø—Ä–µ–¥—ã–¥—É—â–∞—è –ø–æ–∑–∏—Ü–∏—è –±—ã–ª–∞ —Å–∞–º–æ–π –Ω–∏–∑–∫–æ–π)
                    break

            # –®–∞–≥ 2: –¢–æ—á–Ω—ã–π –ø–æ–∏—Å–∫ –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ (best_y, best_y + coarse_step) (—à–∞–≥ 1–º–º)
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã–µ –ø–æ–∑–∏—Ü–∏–∏, –∫–æ—Ç–æ—Ä—ã–µ –º–æ–≥–ª–∏ –ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å –≤ –≥—Ä—É–±–æ–º –ø–æ–∏—Å–∫–µ
            if best_y < current_bottom_y:
                search_start = int(best_y + coarse_step)
                search_end = int(best_y) - 1

                # –ò–¥—ë–º –æ—Ç –±–æ–ª–µ–µ –≤—ã—Å–æ–∫–æ–π –ø–æ–∑–∏—Ü–∏–∏ –∫ best_y
                for test_y in range(search_start, search_end, -1):
                    y_shift = test_y - current_bounds[1]
                    test_polygon = translate_polygon(carpet.polygon, 0, y_shift)

                    test_bounds = test_polygon.bounds
                    if test_bounds[1] < -0.1 or test_bounds[3] > sheet_height_mm + 0.1:
                        continue

                    has_collision = False
                    for obstacle in obstacles:
                        if check_collision(test_polygon, obstacle, min_gap=10.0):
                            has_collision = True
                            break

                    if not has_collision:
                        best_y = test_y
                    else:
                        break  # –ù–∞—à–ª–∏ –∫–æ–ª–ª–∏–∑–∏—é, –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º—Å—è

            # –ü—Ä–∏–º–µ–Ω—è–µ–º –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ –µ—Å–ª–∏ –µ—Å—Ç—å —É–ª—É—á—à–µ–Ω–∏–µ
            if best_y < current_bottom_y - 0.1:  # –•–æ—Ç—è –±—ã 0.1–º–º —É–ª—É—á—à–µ–Ω–∏—è
                y_shift = best_y - current_bounds[1]
                movement = current_bottom_y - best_y
                logger.info(
                    f"     ‚úì –ö–æ–≤—ë—Ä {i}: –æ–ø—É—â–µ–Ω –Ω–∞ {movement:.1f}–º–º (Y={current_bottom_y:.1f} ‚Üí {best_y:.1f})"
                )
                carpet.polygon = translate_polygon(carpet.polygon, 0, y_shift)
                carpet.y_offset += y_shift
                any_movement = True
            else:
                logger.debug(
                    f"     –ö–æ–≤—ë—Ä {i}: –Ω–µ –º–æ–∂–µ—Ç –æ–ø—É—Å—Ç–∏—Ç—å—Å—è –Ω–∏–∂–µ (best_y={best_y:.1f})"
                )

        # –ï—Å–ª–∏ –Ω–∏—á–µ–≥–æ –Ω–µ –¥–≤–∏–≥–∞–ª–æ—Å—å, –∑–∞–≤–µ—Ä—à–∞–µ–º
        if not any_movement:
            logger.info("   –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–∞—è –≥—Ä–∞–≤–∏—Ç–∞—Ü–∏—è: –Ω–µ—Ç –±–æ–ª—å—à–µ –¥–≤–∏–∂–µ–Ω–∏–π, –∑–∞–≤–µ—Ä—à–∞–µ–º")
            break

    return result


def apply_aggressive_horizontal_compaction(
    placed_carpets: list[PlacedCarpet],
    sheet_width_mm: float,
    sheet_height_mm: float,
    max_iterations: int = 10,
) -> list[PlacedCarpet]:
    """
    üéØ –ê–ì–†–ï–°–°–ò–í–ù–ê–Ø –ì–û–†–ò–ó–û–ù–¢–ê–õ–¨–ù–ê–Ø –ö–û–ú–ü–†–ï–°–°–ò–Ø: –ü—Ä–∏–∂–∏–º–∞–µ—Ç –í–°–ï –∫–æ–≤—Ä—ã –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –≤–ª–µ–≤–æ.

    –°—Ç—Ä–∞—Ç–µ–≥–∏—è:
    1. –°–æ—Ä—Ç–∏—Ä—É–µ—Ç –∫–æ–≤—Ä—ã —Å–ª–µ–≤–∞ –Ω–∞–ø—Ä–∞–≤–æ (–ª–µ–≤—ã–µ –Ω–µ –¥–≤–∏–≥–∞—é—Ç—Å—è, –ø—Ä–∞–≤—ã–µ —Å–¥–≤–∏–≥–∞—é—Ç—Å—è –≤–ª–µ–≤–æ)
    2. –î–ª—è –∫–∞–∂–¥–æ–≥–æ –∫–æ–≤—Ä–∞ –Ω–∞—Ö–æ–¥–∏—Ç —Å–∞–º—É—é –ª–µ–≤—É—é –≤–æ–∑–º–æ–∂–Ω—É—é –ø–æ–∑–∏—Ü–∏—é
    3. –ü–æ–≤—Ç–æ—Ä—è–µ—Ç –Ω–µ—Å–∫–æ–ª—å–∫–æ –∏—Ç–µ—Ä–∞—Ü–∏–π –¥–ª—è –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–π –ø–ª–æ—Ç–Ω–æ—Å—Ç–∏

    Args:
        placed_carpets: –†–∞–∑–º–µ—â—ë–Ω–Ω—ã–µ –∫–æ–≤—Ä—ã
        sheet_width_mm: –®–∏—Ä–∏–Ω–∞ –ª–∏—Å—Ç–∞
        sheet_height_mm: –í—ã—Å–æ—Ç–∞ –ª–∏—Å—Ç–∞
        max_iterations: –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∏—Ç–µ—Ä–∞—Ü–∏–π

    Returns:
        –ö–æ–≤—Ä—ã –ø–æ—Å–ª–µ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–æ–π –∫–æ–º–ø—Ä–µ—Å—Å–∏–∏
    """
    if not placed_carpets:
        return placed_carpets

    # –°–æ–∑–¥–∞–µ–º –∫–æ–ø–∏–∏
    result = []
    for carpet in placed_carpets:
        result.append(
            PlacedCarpet(
                polygon=carpet.polygon,
                x_offset=carpet.x_offset,
                y_offset=carpet.y_offset,
                angle=carpet.angle,
                filename=carpet.filename,
                color=carpet.color,
                order_id=carpet.order_id,
                carpet_id=carpet.carpet_id,
                priority=carpet.priority,
            )
        )

    # –ò—Ç–µ—Ä–∞—Ç–∏–≤–Ω–æ –ø—Ä–∏–º–µ–Ω—è–µ–º –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—É—é –∫–æ–º–ø—Ä–µ—Å—Å–∏—é
    for iteration in range(max_iterations):
        any_movement = False
        logger.info(
            f"   –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–∞—è –∫–æ–º–ø—Ä–µ—Å—Å–∏—è - –∏—Ç–µ—Ä–∞—Ü–∏—è {iteration + 1}/{max_iterations}"
        )

        # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ X (—Å–ª–µ–≤–∞ –Ω–∞–ø—Ä–∞–≤–æ) - –ª–µ–≤—ã–µ —Å–Ω–∞—á–∞–ª–∞, –æ–Ω–∏ —Å—Ç–∞–±–∏–ª—å–Ω—ã
        result.sort(key=lambda c: c.polygon.bounds[0])

        # –ü—ã—Ç–∞–µ–º—Å—è —Å–¥–≤–∏–Ω—É—Ç—å –∫–∞–∂–¥—ã–π –∫–æ–≤—ë—Ä –≤–ª–µ–≤–æ
        for i, carpet in enumerate(result):
            current_bounds = carpet.polygon.bounds
            current_left_x = current_bounds[0]

            # –ï—Å–ª–∏ —É–∂–µ —É –ª–µ–≤–æ–π –≥—Ä–∞–Ω–∏—Ü—ã, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º
            if current_left_x < 1:
                logger.debug(
                    f"     –ö–æ–≤—ë—Ä {i} —É–∂–µ —É –ª–µ–≤–æ–π –≥—Ä–∞–Ω–∏—Ü—ã (X={current_left_x:.1f})"
                )
                continue

            # –ü—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è = –≤—Å–µ –æ—Å—Ç–∞–ª—å–Ω—ã–µ –∫–æ–≤—Ä—ã
            obstacles = [other.polygon for j, other in enumerate(result) if j != i]

            # –ò—â–µ–º —Å–∞–º—É—é –ª–µ–≤—É—é –ø–æ–∑–∏—Ü–∏—é –±–µ–∑ –∫–æ–ª–ª–∏–∑–∏–π
            best_x = current_left_x
            logger.debug(f"     –ö–æ–≤—ë—Ä {i}: —Ç–µ–∫—É—â–∞—è –ø–æ–∑–∏—Ü–∏—è X={current_left_x:.1f}")

            # –®–∞–≥ 1: –ì—Ä—É–±—ã–π –ø–æ–∏—Å–∫ —Å–ø—Ä–∞–≤–∞ –Ω–∞–ª–µ–≤–æ (—à–∞–≥ 5–º–º)
            coarse_step = 5

            # –ò–¥—ë–º –æ—Ç —Ç–µ–∫—É—â–µ–π –ø–æ–∑–∏—Ü–∏–∏ –≤–ª–µ–≤–æ –¥–æ X=0
            for test_x in range(int(current_left_x), -1, -coarse_step):
                x_shift = test_x - current_bounds[0]
                test_polygon = translate_polygon(carpet.polygon, x_shift, 0)

                test_bounds = test_polygon.bounds
                if test_bounds[0] < -0.1 or test_bounds[2] > sheet_width_mm + 0.1:
                    break  # –í—ã—à–ª–∏ –∑–∞ –≥—Ä–∞–Ω–∏—Ü—ã –ª–∏—Å—Ç–∞

                has_collision = False
                for obstacle in obstacles:
                    if check_collision(test_polygon, obstacle, min_gap=10.0):
                        has_collision = True
                        break

                if not has_collision:
                    # –≠—Ç–∞ –ø–æ–∑–∏—Ü–∏—è –≤–∞–ª–∏–¥–Ω–∞, –∑–∞–ø–æ–º–∏–Ω–∞–µ–º –∏ –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º –¥–≤–∏–≥–∞—Ç—å—Å—è –≤–ª–µ–≤–æ
                    best_x = test_x
                else:
                    # –ù–∞—à–ª–∏ –∫–æ–ª–ª–∏–∑–∏—é, –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º—Å—è (–ø—Ä–µ–¥—ã–¥—É—â–∞—è –ø–æ–∑–∏—Ü–∏—è –±—ã–ª–∞ —Å–∞–º–æ–π –ª–µ–≤–æ–π)
                    break

            # –®–∞–≥ 2: –¢–æ—á–Ω—ã–π –ø–æ–∏—Å–∫ –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ (best_x, best_x + coarse_step) (—à–∞–≥ 1–º–º)
            if best_x < current_left_x:
                search_start = int(best_x + coarse_step)
                search_end = int(best_x) - 1

                # –ò–¥—ë–º –æ—Ç –±–æ–ª–µ–µ –ø—Ä–∞–≤–æ–π –ø–æ–∑–∏—Ü–∏–∏ –∫ best_x
                for test_x in range(search_start, search_end, -1):
                    x_shift = test_x - current_bounds[0]
                    test_polygon = translate_polygon(carpet.polygon, x_shift, 0)

                    test_bounds = test_polygon.bounds
                    if test_bounds[0] < -0.1 or test_bounds[2] > sheet_width_mm + 0.1:
                        continue

                    has_collision = False
                    for obstacle in obstacles:
                        if check_collision(test_polygon, obstacle, min_gap=10.0):
                            has_collision = True
                            break

                    if not has_collision:
                        best_x = test_x
                    else:
                        break  # –ù–∞—à–ª–∏ –∫–æ–ª–ª–∏–∑–∏—é, –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º—Å—è

            # –ü—Ä–∏–º–µ–Ω—è–µ–º –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ –µ—Å–ª–∏ –µ—Å—Ç—å —É–ª—É—á—à–µ–Ω–∏–µ
            if best_x < current_left_x - 0.1:  # –•–æ—Ç—è –±—ã 0.1–º–º —É–ª—É—á—à–µ–Ω–∏—è
                x_shift = best_x - current_bounds[0]
                movement = current_left_x - best_x
                logger.info(
                    f"     ‚úì –ö–æ–≤—ë—Ä {i}: —Å–¥–≤–∏–Ω—É—Ç –≤–ª–µ–≤–æ –Ω–∞ {movement:.1f}–º–º (X={current_left_x:.1f} ‚Üí {best_x:.1f})"
                )
                carpet.polygon = translate_polygon(carpet.polygon, x_shift, 0)
                carpet.x_offset += x_shift
                any_movement = True
            else:
                logger.debug(
                    f"     –ö–æ–≤—ë—Ä {i}: –Ω–µ –º–æ–∂–µ—Ç —Å–¥–≤–∏–Ω—É—Ç—å—Å—è –≤–ª–µ–≤–æ (best_x={best_x:.1f})"
                )

        # –ï—Å–ª–∏ –Ω–∏—á–µ–≥–æ –Ω–µ –¥–≤–∏–≥–∞–ª–æ—Å—å, –∑–∞–≤–µ—Ä—à–∞–µ–º
        if not any_movement:
            logger.info("   –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–∞—è –∫–æ–º–ø—Ä–µ—Å—Å–∏—è: –Ω–µ—Ç –±–æ–ª—å—à–µ –¥–≤–∏–∂–µ–Ω–∏–π, –∑–∞–≤–µ—Ä—à–∞–µ–º")
            break

    return result


def apply_combined_compaction(
    placed_carpets: list[PlacedCarpet],
    sheet_width_mm: float,
    sheet_height_mm: float,
    max_iterations: int = 5,
) -> list[PlacedCarpet]:
    """
    üéØ –ö–û–ú–ë–ò–ù–ò–†–û–í–ê–ù–ù–ê–Ø –ö–û–ú–ü–†–ï–°–°–ò–Ø: –ß–µ—Ä–µ–¥—É–µ—Ç –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—É—é –≥—Ä–∞–≤–∏—Ç–∞—Ü–∏—é –∏ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—É—é –∫–æ–º–ø—Ä–µ—Å—Å–∏—é.

    –°—Ç—Ä–∞—Ç–µ–≥–∏—è:
    1. –ü—Ä–∏–º–µ–Ω—è–µ—Ç –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—É—é –≥—Ä–∞–≤–∏—Ç–∞—Ü–∏—é (–æ–ø—É—Å–∫–∞–µ—Ç –≤–Ω–∏–∑)
    2. –ü—Ä–∏–º–µ–Ω—è–µ—Ç –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—É—é –∫–æ–º–ø—Ä–µ—Å—Å–∏—é (–ø—Ä–∏–∂–∏–º–∞–µ—Ç –≤–ª–µ–≤–æ)
    3. –ü–æ–≤—Ç–æ—Ä—è–µ—Ç —Ü–∏–∫–ª –ø–æ–∫–∞ –µ—Å—Ç—å –¥–≤–∏–∂–µ–Ω–∏–µ

    Args:
        placed_carpets: –†–∞–∑–º–µ—â—ë–Ω–Ω—ã–µ –∫–æ–≤—Ä—ã
        sheet_width_mm: –®–∏—Ä–∏–Ω–∞ –ª–∏—Å—Ç–∞
        sheet_height_mm: –í—ã—Å–æ—Ç–∞ –ª–∏—Å—Ç–∞
        max_iterations: –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤–Ω–µ—à–Ω–∏—Ö –∏—Ç–µ—Ä–∞—Ü–∏–π

    Returns:
        –ö–æ–≤—Ä—ã –ø–æ—Å–ª–µ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è –∫–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ–π –∫–æ–º–ø—Ä–µ—Å—Å–∏–∏
    """
    if not placed_carpets:
        return placed_carpets

    result = placed_carpets

    for iteration in range(max_iterations):
        logger.info(
            f"üîÑ –ö–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –∫–æ–º–ø—Ä–µ—Å—Å–∏—è - —Ü–∏–∫–ª {iteration + 1}/{max_iterations}"
        )

        # –ó–∞–ø–æ–º–∏–Ω–∞–µ–º —Ç–µ–∫—É—â–∏–µ –ø–æ–∑–∏—Ü–∏–∏ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –¥–≤–∏–∂–µ–Ω–∏—è
        before_positions = [(c.polygon.bounds[0], c.polygon.bounds[1]) for c in result]

        # –®–∞–≥ 1: –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–∞—è –≥—Ä–∞–≤–∏—Ç–∞—Ü–∏—è (–æ–ø—É—Å–∫–∞–µ–º –≤–Ω–∏–∑)
        result = apply_aggressive_gravity(
            result, sheet_width_mm, sheet_height_mm, max_iterations=3
        )

        # –®–∞–≥ 2: –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–∞—è –∫–æ–º–ø—Ä–µ—Å—Å–∏—è (–ø—Ä–∏–∂–∏–º–∞–µ–º –≤–ª–µ–≤–æ)
        result = apply_aggressive_horizontal_compaction(
            result, sheet_width_mm, sheet_height_mm, max_iterations=3
        )

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –±—ã–ª–æ –ª–∏ –¥–≤–∏–∂–µ–Ω–∏–µ
        after_positions = [(c.polygon.bounds[0], c.polygon.bounds[1]) for c in result]

        total_movement = sum(
            abs(before[0] - after[0]) + abs(before[1] - after[1])
            for before, after in zip(before_positions, after_positions)
        )

        logger.info(
            f"   –û–±—â–µ–µ –¥–≤–∏–∂–µ–Ω–∏–µ –≤ —Ü–∏–∫–ª–µ {iteration + 1}: {total_movement:.1f}–º–º"
        )

        if total_movement < 1.0:  # –ú–µ–Ω—å—à–µ 1–º–º —Å—É–º–º–∞—Ä–Ω–æ–≥–æ –¥–≤–∏–∂–µ–Ω–∏—è - —Å—Ç–∞–±–∏–ª–∏–∑–∞—Ü–∏—è
            logger.info("   –ö–æ–º–ø—Ä–µ—Å—Å–∏—è —Å—Ç–∞–±–∏–ª–∏–∑–∏—Ä–æ–≤–∞–ª–∞—Å—å, –∑–∞–≤–µ—Ä—à–∞–µ–º")
            break

    return result


def apply_tetris_right_compaction(
    placed_carpets: list[PlacedCarpet], sheet_width_mm: float, sheet_height_mm: float
) -> list[PlacedCarpet]:
    """
    –ù–û–í–ê–Ø TETRIS-–§–£–ù–ö–¶–ò–Ø: –°–∂–∏–º–∞–µ—Ç –∫–æ–≤—Ä—ã –∫ –ø—Ä–∞–≤–æ–º—É –∫—Ä–∞—é –¥–ª—è –æ—Å–≤–æ–±–æ–∂–¥–µ–Ω–∏—è –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–∞.
    –≠—Ç–æ –ø–æ–∑–≤–æ–ª—è–µ—Ç –≤–µ—Ä—Ö–Ω–∏–º –∫–æ–≤—Ä–∞–º —É–ø–∞—Å—Ç—å –≤–Ω–∏–∑, –∫–∞–∫ –≤ –Ω–∞—Å—Ç–æ—è—â–µ–º –¢–µ—Ç—Ä–∏—Å–µ.
    """
    if not placed_carpets or len(placed_carpets) < 2:
        return placed_carpets

    # –°–æ–∑–¥–∞–µ–º –∫–æ–ø–∏–∏ –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
    compacted_carpets = []
    for carpet in placed_carpets:
        compacted_carpets.append(
            PlacedCarpet(
                polygon=carpet.polygon,
                x_offset=carpet.x_offset,
                y_offset=carpet.y_offset,
                angle=carpet.angle,
                filename=carpet.filename,
                color=carpet.color,
                order_id=carpet.order_id,
                carpet_id=carpet.carpet_id,
                priority=carpet.priority,
            )
        )

    # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—é –æ—Ç –ø—Ä–∞–≤–æ–≥–æ –∫—Ä–∞—è (–¥–∞–ª—å–Ω–∏–µ —Å–Ω–∞—á–∞–ª–∞)
    compacted_carpets.sort(
        key=lambda c: sheet_width_mm - c.polygon.bounds[2], reverse=True
    )

    movements_made = 0
    max_movements = min(5, len(compacted_carpets))  # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–≤–∏–∂–µ–Ω–∏–π

    # –ü—Ä–∏–º–µ–Ω—è–µ–º —Å–∂–∞—Ç–∏–µ –∫ –ø—Ä–∞–≤–æ–º—É –∫—Ä–∞—é
    for i, carpet in enumerate(compacted_carpets):
        if movements_made >= max_movements:
            break

        # –ü—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è = –≤—Å–µ –æ—Å—Ç–∞–ª—å–Ω—ã–µ –∫–æ–≤—Ä—ã
        obstacles = [
            other.polygon for j, other in enumerate(compacted_carpets) if j != i
        ]

        # –¢–µ–∫—É—â–∏–µ –≥—Ä–∞–Ω–∏—Ü—ã –∫–æ–≤—Ä–∞
        current_bounds = carpet.polygon.bounds
        current_right = current_bounds[2]
        carpet_width = current_bounds[2] - current_bounds[0]

        # –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –≤–æ–∑–º–æ–∂–Ω—ã–π —Å–¥–≤–∏–≥ –≤–ø—Ä–∞–≤–æ
        current_left = current_bounds[0]

        if current_right >= sheet_width_mm - 10:  # –£–∂–µ —É –ø—Ä–∞–≤–æ–≥–æ –∫—Ä–∞—è
            continue

        # –ü—Ä–æ–±—É–µ–º —Å–¥–≤–∏–Ω—É—Ç—å –≤–ø—Ä–∞–≤–æ
        best_x = current_left
        improvement_found = False

        # –®–∞–≥–∞–µ–º –≤–ø—Ä–∞–≤–æ —Å —à–∞–≥–æ–º 5–º–º
        for test_right_x in range(int(current_right) + 5, int(sheet_width_mm), 5):
            test_left_x = test_right_x - carpet_width

            if test_left_x < 0 or test_right_x > sheet_width_mm:
                break

            # –°–æ–∑–¥–∞–µ–º —Ç–µ—Å—Ç–æ–≤—ã–π –ø–æ–ª–∏–≥–æ–Ω
            x_shift = test_left_x - current_bounds[0]
            y_shift = 0  # –ù–µ –¥–≤–∏–≥–∞–µ–º –ø–æ Y
            test_polygon = translate_polygon(carpet.polygon, x_shift, y_shift)

            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –≥—Ä–∞–Ω–∏—Ü—ã –ª–∏—Å—Ç–∞
            test_bounds = test_polygon.bounds
            if (
                test_bounds[0] < 0
                or test_bounds[1] < 0
                or test_bounds[2] > sheet_width_mm
                or test_bounds[3] > sheet_height_mm
            ):
                break

            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–ª–ª–∏–∑–∏–∏
            collision = False
            for obstacle in obstacles:
                if check_collision(test_polygon, obstacle, min_gap=10.0):
                    collision = True
                    break

            if not collision:
                best_x = test_left_x
                improvement_found = True
            else:
                break  # –ù–∞—Ç–æ–ª–∫–Ω—É–ª–∏—Å—å –Ω–∞ –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–µ, –¥–∞–ª—å—à–µ –Ω–µ –¥–≤–∏–≥–∞–µ–º—Å—è

        # –ü—Ä–∏–º–µ–Ω—è–µ–º —É–ª—É—á—à–µ–Ω–∏–µ
        if improvement_found and best_x > current_left + 3:  # –ú–∏–Ω–∏–º—É–º 3–º–º —É–ª—É—á—à–µ–Ω–∏—è
            x_shift = best_x - current_bounds[0]
            new_polygon = translate_polygon(carpet.polygon, x_shift, 0)

            # –û–±–Ω–æ–≤–ª—è–µ–º –∫–æ–≤–µ—Ä
            compacted_carpets[i] = PlacedCarpet(
                polygon=new_polygon,
                x_offset=carpet.x_offset + x_shift,
                y_offset=carpet.y_offset,
                angle=carpet.angle,
                filename=carpet.filename,
                color=carpet.color,
                order_id=carpet.order_id,
                carpet_id=carpet.carpet_id,
                priority=carpet.priority,
            )
            movements_made += 1

    return compacted_carpets


def apply_tetris_left_compaction(
    placed_carpets: list[PlacedCarpet], sheet_width_mm: float, sheet_height_mm: float
) -> list[PlacedCarpet]:
    """
    TETRIS-–§–£–ù–ö–¶–ò–Ø: –°–∂–∏–º–∞–µ—Ç –∫–æ–≤—Ä—ã –∫ –ª–µ–≤–æ–º—É –∫—Ä–∞—é –¥–ª—è –ø–ª–æ—Ç–Ω–æ–π —É–ø–∞–∫–æ–≤–∫–∏.
    """
    if not placed_carpets or len(placed_carpets) < 2:
        return placed_carpets

    # –°–æ–∑–¥–∞–µ–º –∫–æ–ø–∏–∏ –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
    compacted_carpets = []
    for carpet in placed_carpets:
        compacted_carpets.append(
            PlacedCarpet(
                polygon=carpet.polygon,
                x_offset=carpet.x_offset,
                y_offset=carpet.y_offset,
                angle=carpet.angle,
                filename=carpet.filename,
                color=carpet.color,
                order_id=carpet.order_id,
                carpet_id=carpet.carpet_id,
                priority=carpet.priority,
            )
        )

    # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—é –æ—Ç –ª–µ–≤–æ–≥–æ –∫—Ä–∞—è (–¥–∞–ª—å–Ω–∏–µ —Å–Ω–∞—á–∞–ª–∞)
    compacted_carpets.sort(key=lambda c: c.polygon.bounds[0], reverse=True)

    movements_made = 0
    max_movements = min(5, len(compacted_carpets))

    # –ü—Ä–∏–º–µ–Ω—è–µ–º —Å–∂–∞—Ç–∏–µ –∫ –ª–µ–≤–æ–º—É –∫—Ä–∞—é
    for i, carpet in enumerate(compacted_carpets):
        if movements_made >= max_movements:
            break

        # –ü—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è = –≤—Å–µ –æ—Å—Ç–∞–ª—å–Ω—ã–µ –∫–æ–≤—Ä—ã
        obstacles = [
            other.polygon for j, other in enumerate(compacted_carpets) if j != i
        ]

        # –¢–µ–∫—É—â–∏–µ –≥—Ä–∞–Ω–∏—Ü—ã –∫–æ–≤—Ä–∞
        current_bounds = carpet.polygon.bounds
        current_left = current_bounds[0]

        if current_left <= 10:  # –£–∂–µ —É –ª–µ–≤–æ–≥–æ –∫—Ä–∞—è
            continue

        # –ü—Ä–æ–±—É–µ–º —Å–¥–≤–∏–Ω—É—Ç—å –≤–ª–µ–≤–æ
        best_x = current_left
        improvement_found = False

        # –®–∞–≥–∞–µ–º –≤–ª–µ–≤–æ —Å —à–∞–≥–æ–º 5–º–º
        for test_left_x in range(int(current_left) - 5, -1, -5):
            if test_left_x < 0:
                break

            # –°–æ–∑–¥–∞–µ–º —Ç–µ—Å—Ç–æ–≤—ã–π –ø–æ–ª–∏–≥–æ–Ω
            x_shift = test_left_x - current_bounds[0]
            y_shift = 0  # –ù–µ –¥–≤–∏–≥–∞–µ–º –ø–æ Y
            test_polygon = translate_polygon(carpet.polygon, x_shift, y_shift)

            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –≥—Ä–∞–Ω–∏—Ü—ã –ª–∏—Å—Ç–∞
            test_bounds = test_polygon.bounds
            if (
                test_bounds[0] < 0
                or test_bounds[1] < 0
                or test_bounds[2] > sheet_width_mm
                or test_bounds[3] > sheet_height_mm
            ):
                break

            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–ª–ª–∏–∑–∏–∏
            collision = False
            for obstacle in obstacles:
                if check_collision(test_polygon, obstacle, min_gap=10.0):
                    collision = True
                    break

            if not collision:
                best_x = test_left_x
                improvement_found = True
            else:
                break  # –ù–∞—Ç–æ–ª–∫–Ω—É–ª–∏—Å—å –Ω–∞ –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–µ, –¥–∞–ª—å—à–µ –Ω–µ –¥–≤–∏–≥–∞–µ–º—Å—è

        # –ü—Ä–∏–º–µ–Ω—è–µ–º —É–ª—É—á—à–µ–Ω–∏–µ
        if improvement_found and best_x < current_left - 3:  # –ú–∏–Ω–∏–º—É–º 3–º–º —É–ª—É—á—à–µ–Ω–∏—è
            x_shift = best_x - current_bounds[0]
            new_polygon = translate_polygon(carpet.polygon, x_shift, 0)

            # –û–±–Ω–æ–≤–ª—è–µ–º –∫–æ–≤–µ—Ä
            compacted_carpets[i] = PlacedCarpet(
                polygon=new_polygon,
                x_offset=carpet.x_offset + x_shift,
                y_offset=carpet.y_offset,
                angle=carpet.angle,
                filename=carpet.filename,
                color=carpet.color,
                order_id=carpet.order_id,
                carpet_id=carpet.carpet_id,
                priority=carpet.priority,
            )
            movements_made += 1

    return compacted_carpets


def calculate_trapped_space(
    placed_carpets: list[PlacedCarpet], sheet_width_mm: float, sheet_height_mm: float
) -> float:
    """
    üîç –ê–ù–ê–õ–ò–ó –ó–ê–ü–ï–†–ù–´–• –ó–û–ù: –í—ã—á–∏—Å–ª—è–µ—Ç –ø–ª–æ—â–∞–¥—å –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–∞, –∑–∞–ø–µ—Ä–Ω–æ–≥–æ –∫–æ–≤—Ä–∞–º–∏.
    –ó–∞–ø–µ—Ä–Ω–æ–µ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ = –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ –¥–ª—è –±—É–¥—É—â–∏—Ö –∫–æ–≤—Ä–æ–≤ –∏–∑-–∑–∞ —Ä–∞–∑–º–µ—â–µ–Ω–∏—è —Ç–µ–∫—É—â–∏—Ö.
    """
    if not placed_carpets:
        return 0

    from shapely.geometry import box
    from shapely.ops import unary_union

    # –°–æ–∑–¥–∞–µ–º –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫ –ª–∏—Å—Ç–∞
    sheet_box = box(0, 0, sheet_width_mm, sheet_height_mm)

    # –û–±—ä–µ–¥–∏–Ω—è–µ–º –≤—Å–µ —Ä–∞–∑–º–µ—â–µ–Ω–Ω—ã–µ –∫–æ–≤—Ä—ã
    placed_union = unary_union([carpet.polygon for carpet in placed_carpets])

    # –ù–∞—Ö–æ–¥–∏–º —Å–≤–æ–±–æ–¥–Ω–æ–µ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ
    free_space = sheet_box.difference(placed_union)

    # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º —Å–≤—è–∑–Ω–æ—Å—Ç—å —Å–≤–æ–±–æ–¥–Ω—ã—Ö –æ–±–ª–∞—Å—Ç–µ–π
    if hasattr(free_space, "geoms"):  # MultiPolygon
        free_polygons = list(free_space.geoms)
    else:  # Single Polygon
        free_polygons = [free_space] if free_space.area > 0 else []

    # –í—ã—á–∏—Å–ª—è–µ–º "–∑–∞–ø–µ—Ä–Ω–æ—Å—Ç—å" –∫–∞–∂–¥–æ–π —Å–≤–æ–±–æ–¥–Ω–æ–π –æ–±–ª–∞—Å—Ç–∏
    trapped_area = 0
    min_useful_area = 200 * 200  # 20x20—Å–º - –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –ø–æ–ª–µ–∑–Ω—ã–π —Ä–∞–∑–º–µ—Ä

    for poly in free_polygons:
        if poly.area < min_useful_area:
            continue  # –°–ª–∏—à–∫–æ–º –º–∞–ª–µ–Ω—å–∫–∏–µ –Ω–µ —Å—á–∏—Ç–∞–µ–º

        bounds = poly.bounds
        width = bounds[2] - bounds[0]
        height = bounds[3] - bounds[1]

        # –û–±–ª–∞—Å—Ç—å —Å—á–∏—Ç–∞–µ—Ç—Å—è "–∑–∞–ø–µ—Ä–Ω–æ–π" –µ—Å–ª–∏ –æ–Ω–∞:
        # 1. –û–∫—Ä—É–∂–µ–Ω–∞ –∫–æ–≤—Ä–∞–º–∏ —Å –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö —Å—Ç–æ—Ä–æ–Ω
        # 2. –ò–º–µ–µ—Ç –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω—É—é —Ñ–æ—Ä–º—É (–Ω–∏–∑–∫–∏–π –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–æ—Å—Ç–∏)
        rectangularity = poly.area / (width * height)

        if rectangularity < 0.7:  # –ú–µ–Ω–µ–µ 70% –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–æ—Å—Ç–∏ (–±–æ–ª–µ–µ —Å—Ç—Ä–æ–≥–∏–π –∫—Ä–∏—Ç–µ—Ä–∏–π)
            trapped_area += poly.area * (
                1.2 - rectangularity
            )  # –£–≤–µ–ª–∏—á–µ–Ω–Ω—ã–π —à—Ç—Ä–∞—Ñ –∑–∞ –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ—Å—Ç—å

        # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π —à—Ç—Ä–∞—Ñ –∑–∞ –æ–±–ª–∞—Å—Ç–∏ –¥–∞–ª–µ–∫–æ –æ—Ç –∫—Ä–∞–µ–≤ –ª–∏—Å—Ç–∞
        center_x = (bounds[0] + bounds[2]) / 2
        center_y = (bounds[1] + bounds[3]) / 2

        distance_from_edges = min(
            center_x,  # –û—Ç –ª–µ–≤–æ–≥–æ –∫—Ä–∞—è
            sheet_width_mm - center_x,  # –û—Ç –ø—Ä–∞–≤–æ–≥–æ –∫—Ä–∞—è
            center_y,  # –û—Ç –Ω–∏–∂–Ω–µ–≥–æ –∫—Ä–∞—è
            sheet_height_mm - center_y,  # –û—Ç –≤–µ—Ä—Ö–Ω–µ–≥–æ –∫—Ä–∞—è
        )

        if distance_from_edges > 200:  # –ë–æ–ª—å—à–µ 20—Å–º –æ—Ç –∫—Ä–∞–µ–≤
            isolation_penalty = (distance_from_edges - 200) / 100
            trapped_area += poly.area * isolation_penalty * 0.1

    return trapped_area


def analyze_placement_blocking(
    placed_carpets: list[PlacedCarpet], sheet_width_mm: float, sheet_height_mm: float
) -> dict:
    """
    üß† –ê–ù–ê–õ–ò–ó –ë–õ–û–ö–ò–†–û–í–ö–ò: –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç –∫–∞–∫ —Ä–∞–∑–º–µ—â–µ–Ω–Ω—ã–µ –∫–æ–≤—Ä—ã –±–ª–æ–∫–∏—Ä—É—é—Ç –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ –¥–ª—è –±—É–¥—É—â–∏—Ö –∫–æ–≤—Ä–æ–≤.
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ —É–ª—É—á—à–µ–Ω–∏—é —Ä–∞–∑–º–µ—â–µ–Ω–∏—è.
    """
    analysis = {
        "total_trapped_area": 0,
        "blocking_carpets": [],  # –ö–æ–≤—Ä—ã, —Å–æ–∑–¥–∞—é—â–∏–µ –º–Ω–æ–≥–æ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏
        "improvement_suggestions": [],
    }

    if len(placed_carpets) < 2:
        return analysis

    # –ë–∞–∑–æ–≤–∞—è –∑–∞–ø–µ—Ä–Ω–æ—Å—Ç—å
    base_trapped = calculate_trapped_space(
        placed_carpets, sheet_width_mm, sheet_height_mm
    )
    analysis["total_trapped_area"] = base_trapped

    # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –≤–∫–ª–∞–¥ –∫–∞–∂–¥–æ–≥–æ –∫–æ–≤—Ä–∞ –≤ –±–ª–æ–∫–∏—Ä–æ–≤–∫—É
    for i, carpet in enumerate(placed_carpets):
        # –£–±–∏—Ä–∞–µ–º —ç—Ç–æ—Ç –∫–æ–≤–µ—Ä –∏ —Å–º–æ—Ç—Ä–∏–º, –∫–∞–∫ –∏–∑–º–µ–Ω–∏—Ç—Å—è –∑–∞–ø–µ—Ä–Ω–æ—Å—Ç—å
        temp_placed = [c for j, c in enumerate(placed_carpets) if j != i]
        trapped_without = calculate_trapped_space(
            temp_placed, sheet_width_mm, sheet_height_mm
        )

        blocking_contribution = base_trapped - trapped_without

        if (
            blocking_contribution > 1000
        ):  # REDUCED: –ë–æ–ª—å—à–µ 100 —Å–º¬≤ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ (–µ—â–µ –±–æ–ª–µ–µ –∞–≥—Ä–µ—Å—Å–∏–≤–Ω—ã–π –ø–æ—Ä–æ–≥)
            analysis["blocking_carpets"].append(
                {
                    "carpet": carpet,
                    "blocking_amount": blocking_contribution,
                    "carpet_index": i,
                }
            )

            # –ü—Ä–µ–¥–ª–∞–≥–∞–µ–º –ø–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å –ø–æ–≤–æ—Ä–æ—Ç
            analysis["improvement_suggestions"].append(
                {
                    "type": "rotation",
                    "carpet_index": i,
                    "reason": f"–ë–ª–æ–∫–∏—Ä—É–µ—Ç {blocking_contribution/100:.0f} —Å–º¬≤ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–∞",
                }
            )

    return analysis


def post_placement_optimize_aggressive(
    placed_carpets: list[PlacedCarpet],
    sheet_width_mm: float,
    sheet_height_mm: float,
    remaining_carpets: list[Carpet] = None,
) -> list[PlacedCarpet]:
    """
    üöÄ –ê–ì–†–ï–°–°–ò–í–ù–ê–Ø POST-PLACEMENT OPTIMIZATION: –ü–æ–ª–Ω–æ—Å—Ç—å—é –ø–µ—Ä–µ—Ä–∞–∑–º–µ—â–∞–µ—Ç –ø—Ä–æ–±–ª–µ–º–Ω—ã–µ –∫–æ–≤—Ä—ã.
    –ù–µ –ø—Ä–æ—Å—Ç–æ –ø–æ–≤–æ—Ä–∞—á–∏–≤–∞–µ—Ç –Ω–∞ –º–µ—Å—Ç–µ, –∞ –Ω–∞—Ö–æ–¥–∏—Ç –ù–û–í–´–ï –ø–æ–∑–∏—Ü–∏–∏ —Å —É—á–µ—Ç–æ–º –±—É–¥—É—â–∏—Ö –∫–æ–≤—Ä–æ–≤.
    """
    if len(placed_carpets) < 2:
        return placed_carpets

    # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –ø—Ä–æ–±–ª–µ–º—ã
    blocking_analysis = analyze_placement_blocking(
        placed_carpets, sheet_width_mm, sheet_height_mm
    )

    if not blocking_analysis["blocking_carpets"]:
        return placed_carpets

    # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ —Å—Ç–µ–ø–µ–Ω–∏ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ (—Ö—É–¥—à–∏–µ –ø–µ—Ä–≤—ã–µ)
    blocking_carpets = sorted(
        blocking_analysis["blocking_carpets"],
        key=lambda x: x["blocking_amount"],
        reverse=True,
    )

    optimized_carpets = [
        PlacedCarpet(
            polygon=c.polygon,
            x_offset=c.x_offset,
            y_offset=c.y_offset,
            angle=c.angle,
            filename=c.filename,
            color=c.color,
            order_id=c.order_id,
            carpet_id=c.carpet_id,
            priority=c.priority,
        )
        for c in placed_carpets
    ]

    improvements_made = 0
    max_improvements = 5  # INCREASED: –ê–≥—Ä–µ—Å—Å–∏–≤–Ω–æ –ø–µ—Ä–µ—Ä–∞–∑–º–µ—â–∞–µ–º –º–∞–∫—Å–∏–º—É–º 5 —Ö—É–¥—à–∏—Ö –∫–æ–≤—Ä–æ–≤

    for blocker_info in blocking_carpets[:max_improvements]:
        carpet_idx = blocker_info["carpet_index"]
        current_carpet = optimized_carpets[carpet_idx]

        # –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∏—Å—Ö–æ–¥–Ω—É—é —Ñ–æ—Ä–º—É –∫–æ–≤—Ä–∞
        original_polygon = rotate_polygon(current_carpet.polygon, -current_carpet.angle)

        # –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ –æ—Å—Ç–∞–ª—å–Ω—ã–µ –∫–æ–≤—Ä—ã –∫–∞–∫ –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è
        obstacles = [
            c.polygon for i, c in enumerate(optimized_carpets) if i != carpet_idx
        ]

        current_trapped = calculate_trapped_space(
            optimized_carpets, sheet_width_mm, sheet_height_mm
        )
        best_improvement = 0
        best_placement = None

        # –ê–ì–†–ï–°–°–ò–í–ù–ê–Ø –°–¢–†–ê–¢–ï–ì–ò–Ø: –ü—Ä–æ–±—É–µ–º –í–°–ï –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏–∏ + –í–°–ï –ø–æ–∑–∏—Ü–∏–∏
        for test_angle in [0, 90, 180, 270]:
            # angle = test_angle - current_carpet.angle
            # if angle < 0:
            #    angle += 360
            # rotated_polygon = get_cached_rotation(current_carpet, angle)
            rotated_polygon = (
                rotate_polygon(original_polygon, test_angle)
                if test_angle != 0
                else original_polygon
            )

            rot_bounds = rotated_polygon.bounds
            rot_width = rot_bounds[2] - rot_bounds[0]
            rot_height = rot_bounds[3] - rot_bounds[1]

            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –≥—Ä–∞–Ω–∏—Ü—ã –ª–∏—Å—Ç–∞
            if rot_width > sheet_width_mm or rot_height > sheet_height_mm:
                continue

            # –ü—Ä–æ–±—É–µ–º –ú–ù–û–ñ–ï–°–¢–í–û –ø–æ–∑–∏—Ü–∏–π, –Ω–µ —Ç–æ–ª—å–∫–æ bottom-left
            test_positions = []

            # Bottom-left –ø–æ–∑–∏—Ü–∏–∏
            from layout_optimizer import find_bottom_left_position_with_obstacles

            best_x, best_y = find_bottom_left_position_with_obstacles(
                rotated_polygon, obstacles, sheet_width_mm, sheet_height_mm
            )

            if best_x is not None:
                test_positions.append((best_x, best_y))

            # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Å—Ç—Ä–∞—Ç–µ–≥–∏—á–µ—Å–∫–∏–µ –ø–æ–∑–∏—Ü–∏–∏
            step_x, step_y = max(50, rot_width // 4), max(50, rot_height // 4)

            for test_x in range(0, int(sheet_width_mm - rot_width), int(step_x)):
                for test_y in range(0, int(sheet_height_mm - rot_height), int(step_y)):
                    test_positions.append((test_x, test_y))
                    if (
                        len(test_positions) > 15
                    ):  # –£–º–µ–Ω—å—à–∏–ª–∏ –ª–∏–º–∏—Ç –¥–ª—è —É—Å–∫–æ—Ä–µ–Ω–∏—è (–±—ã–ª–æ 20)
                        break
                if len(test_positions) > 15:
                    break

            # –¢–µ—Å—Ç–∏—Ä—É–µ–º –∫–∞–∂–¥—É—é –ø–æ–∑–∏—Ü–∏—é
            for test_x, test_y in test_positions:
                # –°–æ–∑–¥–∞–µ–º —Ç–µ—Å—Ç–æ–≤—ã–π –ø–æ–ª–∏–≥–æ–Ω
                test_polygon = translate_polygon(
                    rotated_polygon, test_x - rot_bounds[0], test_y - rot_bounds[1]
                )

                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–ª–ª–∏–∑–∏–∏
                collision = False
                for obstacle in obstacles:
                    if test_polygon.intersects(obstacle):
                        intersection = test_polygon.intersection(obstacle)
                        if intersection.area > 100:
                            collision = True
                            break

                if not collision:
                    # –¢–µ—Å—Ç–∏—Ä—É–µ–º –∑–∞–ø–µ—Ä–Ω–æ—Å—Ç—å —Å –Ω–æ–≤—ã–º —Ä–∞–∑–º–µ—â–µ–Ω–∏–µ–º
                    test_carpets = optimized_carpets.copy()
                    test_carpets[carpet_idx] = PlacedCarpet(
                        polygon=test_polygon,
                        x_offset=test_x - rot_bounds[0],
                        y_offset=test_y - rot_bounds[1],
                        angle=test_angle,
                        filename=current_carpet.filename,
                        color=current_carpet.color,
                        order_id=current_carpet.order_id,
                        carpet_id=current_carpet.carpet_id,
                        priority=current_carpet.priority,
                    )

                    test_trapped = calculate_trapped_space(
                        test_carpets, sheet_width_mm, sheet_height_mm
                    )
                    improvement = current_trapped - test_trapped

                    if improvement > best_improvement:
                        best_improvement = improvement
                        best_placement = {
                            "polygon": test_polygon,
                            "x_offset": test_x - rot_bounds[0],
                            "y_offset": test_y - rot_bounds[1],
                            "angle": test_angle,
                        }

        # –ü—Ä–∏–º–µ–Ω—è–µ–º –ª—É—á—à–µ–µ —Ä–∞–∑–º–µ—â–µ–Ω–∏–µ –µ—Å–ª–∏ –æ–Ω–æ –∑–Ω–∞—á–∏–º–æ –ª—É—á—à–µ
        if (
            best_placement and best_improvement > 100
        ):  # REDUCED: –ú–∏–Ω–∏–º—É–º 10 —Å–º¬≤ —É–ª—É—á—à–µ–Ω–∏—è (–±–æ–ª–µ–µ –∞–≥—Ä–µ—Å—Å–∏–≤–Ω–æ)
            optimized_carpets[carpet_idx] = PlacedCarpet(
                polygon=best_placement["polygon"],
                x_offset=best_placement["x_offset"],
                y_offset=best_placement["y_offset"],
                angle=best_placement["angle"],
                filename=current_carpet.filename,
                color=current_carpet.color,
                order_id=current_carpet.order_id,
                carpet_id=current_carpet.carpet_id,
                priority=current_carpet.priority,
            )
            improvements_made += 1

    return optimized_carpets


def post_placement_optimize(
    placed_carpets: list[PlacedCarpet], sheet_width_mm: float, sheet_height_mm: float
) -> list[PlacedCarpet]:
    """
    üöÄ POST-PLACEMENT OPTIMIZATION: –†–µ–≤–æ–ª—é—Ü–∏–æ–Ω–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ –ø–µ—Ä–µ—Ä–∞–∑–º–µ—â–µ–Ω–∏—è.
    –ü–æ—Å–ª–µ —Ä–∞–∑–º–µ—â–µ–Ω–∏—è –∞–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç –∏ —É–ª—É—á—à–∞–µ—Ç –ø–æ–∑–∏—Ü–∏–∏ –∫–æ–≤—Ä–æ–≤ –¥–ª—è –º–∏–Ω–∏–º–∏–∑–∞—Ü–∏–∏ –∑–∞–ø–µ—Ä–Ω—ã—Ö –∑–æ–Ω.
    """
    if len(placed_carpets) < 2:
        return placed_carpets

    # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º —Ç–µ–∫—É—â—É—é –±–ª–æ–∫–∏—Ä–æ–≤–∫—É
    blocking_analysis = analyze_placement_blocking(
        placed_carpets, sheet_width_mm, sheet_height_mm
    )

    if not blocking_analysis["blocking_carpets"]:
        return placed_carpets  # –ù–µ—Ç –ø—Ä–æ–±–ª–µ–º–Ω—ã—Ö –∫–æ–≤—Ä–æ–≤

    optimized_carpets = [
        PlacedCarpet(
            polygon=c.polygon,
            x_offset=c.x_offset,
            y_offset=c.y_offset,
            angle=c.angle,
            filename=c.filename,
            color=c.color,
            order_id=c.order_id,
            carpet_id=c.carpet_id,
            priority=c.priority,
        )
        for c in placed_carpets
    ]

    improvements_made = 0
    max_improvements = min(
        5, len(blocking_analysis["blocking_carpets"])
    )  # –£–≤–µ–ª–∏—á–∏–ª–∏ –ª–∏–º–∏—Ç —É–ª—É—á—à–µ–Ω–∏–π

    # –û–ø—Ç–∏–º–∏–∑–∏—Ä—É–µ–º —Å–∞–º—ã–µ –ø—Ä–æ–±–ª–µ–º–Ω—ã–µ –∫–æ–≤—Ä—ã
    for suggestion in blocking_analysis["improvement_suggestions"][:max_improvements]:
        if suggestion["type"] == "rotation":
            carpet_idx = suggestion["carpet_index"]
            current_carpet = optimized_carpets[carpet_idx]

            # –ü—Ä–æ–±—É–µ–º –≤—Å–µ –≤–æ–∑–º–æ–∂–Ω—ã–µ –ø–æ–≤–æ—Ä–æ—Ç—ã
            current_trapped = calculate_trapped_space(
                optimized_carpets, sheet_width_mm, sheet_height_mm
            )
            best_improvement = 0
            best_rotation = None

            # –ü–æ–ª—É—á–∞–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π –ø–æ–ª–∏–≥–æ–Ω –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞
            original_polygon = rotate_polygon(
                current_carpet.polygon, -current_carpet.angle
            )  # –í–æ–∑–≤—Ä–∞—â–∞–µ–º –∫ 0¬∞

            for test_angle in [0, 90, 180, 270]:
                if test_angle == current_carpet.angle:
                    continue
                rotated_polygon = rotate_polygon(original_polygon, test_angle)

                # –°–æ–∑–¥–∞–µ–º —Ç–µ—Å—Ç–æ–≤—ã–π –∫–æ–≤–µ—Ä —Å –Ω–æ–≤—ã–º —É–≥–ª–æ–º
                # angle = test_angle - current_carpet.angle
                # if angle < 0:
                #    angle += 360
                # rotated_polygon = get_cached_rotation(current_carpet, angle)

                # –ü—Ä–æ–±—É–µ–º —Ä–∞–∑–º–µ—Å—Ç–∏—Ç—å –≤ —Ç–æ–π –∂–µ –ø–æ–∑–∏—Ü–∏–∏
                bounds = rotated_polygon.bounds
                rotated_width = bounds[2] - bounds[0]
                rotated_height = bounds[3] - bounds[1]

                # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –ø–æ–º–µ—â–∞–µ—Ç—Å—è –ª–∏ –≤ –ª–∏—Å—Ç
                if rotated_width > sheet_width_mm or rotated_height > sheet_height_mm:
                    continue

                # –°–æ–∑–¥–∞–µ–º —Ç–µ—Å—Ç–æ–≤–æ–µ —Ä–∞–∑–º–µ—â–µ–Ω–∏–µ
                test_x, test_y = (
                    current_carpet.polygon.bounds[0],
                    current_carpet.polygon.bounds[1],
                )
                test_polygon = translate_polygon(
                    rotated_polygon, test_x - bounds[0], test_y - bounds[1]
                )

                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–ª–ª–∏–∑–∏–∏ —Å –¥—Ä—É–≥–∏–º–∏ –∫–æ–≤—Ä–∞–º–∏
                collision = False
                for j, other_carpet in enumerate(optimized_carpets):
                    if j == carpet_idx:
                        continue
                    if test_polygon.intersects(other_carpet.polygon):
                        intersection = test_polygon.intersection(other_carpet.polygon)
                        if intersection.area > 100:
                            collision = True
                            break

                if not collision:
                    # –¢–µ—Å—Ç–∏—Ä—É–µ–º –∑–∞–ø–µ—Ä–Ω–æ—Å—Ç—å —Å –Ω–æ–≤—ã–º –ø–æ–≤–æ—Ä–æ—Ç–æ–º
                    test_carpets = optimized_carpets.copy()
                    test_carpets[carpet_idx] = PlacedCarpet(
                        polygon=test_polygon,
                        x_offset=current_carpet.x_offset,
                        y_offset=current_carpet.y_offset,
                        angle=test_angle,
                        filename=current_carpet.filename,
                        color=current_carpet.color,
                        order_id=current_carpet.order_id,
                        carpet_id=current_carpet.carpet_id,
                        priority=current_carpet.priority,
                    )

                    test_trapped = calculate_trapped_space(
                        test_carpets, sheet_width_mm, sheet_height_mm
                    )
                    improvement = current_trapped - test_trapped

                    if (
                        improvement > best_improvement and improvement > 200
                    ):  # REDUCED: –ú–∏–Ω–∏–º—É–º 20 —Å–º¬≤ —É–ª—É—á—à–µ–Ω–∏—è (–µ—â–µ –±–æ–ª–µ–µ —á—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π)
                        best_improvement = improvement
                        best_rotation = (test_angle, test_polygon)

            # –ü—Ä–∏–º–µ–Ω—è–µ–º –ª—É—á—à–∏–π –ø–æ–≤–æ—Ä–æ—Ç
            if best_rotation:
                optimized_carpets[carpet_idx] = PlacedCarpet(
                    polygon=best_rotation[1],
                    x_offset=current_carpet.x_offset,
                    y_offset=current_carpet.y_offset,
                    angle=best_rotation[0],
                    filename=current_carpet.filename,
                    color=current_carpet.color,
                    order_id=current_carpet.order_id,
                    carpet_id=current_carpet.carpet_id,
                    priority=current_carpet.priority,
                )
                improvements_made += 1

    return optimized_carpets


def calculate_free_top_space(
    placed_carpets: list[PlacedCarpet], sheet_width_mm: float, sheet_height_mm: float
) -> float:
    """
    –í—ã—á–∏—Å–ª—è–µ—Ç –ø–ª–æ—â–∞–¥—å —Å–≤–æ–±–æ–¥–Ω–æ–≥–æ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–∞ —Å–≤–µ—Ä—Ö—É (–∏–¥–µ–∞–ª—å–Ω–æ –¥–ª—è —Å–ª–µ–¥—É—é—â–∏—Ö –∫–æ–≤—Ä–æ–≤).
    –≠—Ç–æ –∫–ª—é—á–µ–≤–∞—è –º–µ—Ç—Ä–∏–∫–∞ –¥–ª—è –¢–µ—Ç—Ä–∏—Å-–æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏.
    """
    if not placed_carpets:
        return sheet_width_mm * sheet_height_mm

    # –ù–∞—Ö–æ–¥–∏–º –º–∞–∫—Å–∏–º–∞–ª—å–Ω—É—é –≤—ã—Å–æ—Ç—É –∑–∞–Ω—è—Ç–æ–≥–æ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–∞
    max_occupied_y = max(carpet.polygon.bounds[3] for carpet in placed_carpets)

    # –°–≤–æ–±–æ–¥–Ω–æ–µ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ —Å–≤–µ—Ä—Ö—É
    free_height = sheet_height_mm - max_occupied_y
    if free_height <= 0:
        return 0

    return sheet_width_mm * free_height


def find_available_sheet_of_color(color, sheet_inventory):
    """Find an available sheet of the specified color."""
    for sheet_type in sheet_inventory:
        if (
            sheet_type.get("color", "—Å–µ—Ä—ã–π") == color
            and sheet_type["count"] - sheet_type["used"] > 0
        ):
            return sheet_type
    return None


def create_new_sheet(sheet_type, sheet_number, color) -> PlacedSheet:
    """Create a new sheet layout."""
    sheet_size = (sheet_type["width"], sheet_type["height"])
    return PlacedSheet(
        sheet_number=sheet_number,
        sheet_type=sheet_type["name"],
        sheet_color=color,
        sheet_size=sheet_size,
        placed_polygons=[],
        usage_percent=0.0,
        orders_on_sheet=[],
    )


def place_polygon_at_origin(polygon: Polygon) -> Polygon:
    """Move polygon so its bottom-left corner is at (0,0)."""
    bounds = polygon.bounds
    return translate_polygon(polygon, -bounds[0], -bounds[1])


def apply_placement_transform(
    polygon: Polygon, x_offset: float, y_offset: float, rotation_angle: int
) -> Polygon:
    """Apply the same transformation sequence used in bin_packing.

    This ensures consistency between visualization and DXF output.

    Args:
        polygon: Original polygon
        x_offset: X translation offset
        y_offset: Y translation offset
        rotation_angle: Rotation angle in degrees

    Returns:
        Transformed polygon
    """
    # Step 1: Move to origin
    bounds = polygon.bounds
    normalized = translate_polygon(polygon, -bounds[0], -bounds[1])

    # Step 2: Rotate around centroid if needed
    if rotation_angle != 0:
        rotated = rotate_polygon(normalized, rotation_angle)
    else:
        rotated = normalized

    # Step 3: Apply final translation
    # Note: x_offset and y_offset already account for the original bounds
    final_polygon = translate_polygon(
        rotated, x_offset + bounds[0], y_offset + bounds[1]
    )

    return final_polygon


def check_collision_with_strtree(
    polygon: Polygon, placed_polygons: list[Polygon]
) -> bool:
    """Ultra-fast collision check using CACHED STRtree spatial index."""
    if not placed_polygons:
        return False

    if not polygon.is_valid:
        return True

    # OPTIMIZATION: Use cached STRtree with intersects only (bc9bc54 behavior)
    global _global_spatial_cache
    _global_spatial_cache.update(placed_polygons)
    return check_collision_fast_indexed_intersects_only(polygon, _global_spatial_cache)


def check_collision_fast(
    polygon1: Polygon, polygon2: Polygon, min_gap: float = 0.1
) -> bool:
    """FIXED fast collision check - PRIORITY: Accuracy over speed."""
    # Fast validity check
    if not (polygon1.is_valid and polygon2.is_valid):
        return True

    try:
        # CRITICAL FIX: Check intersection and area
        if polygon1.intersects(polygon2):
            return True

        # SPEED OPTIMIZATION: Only use bbox pre-filter for distant objects
        bounds1 = polygon1.bounds
        bounds2 = polygon2.bounds

        # Calculate minimum possible distance between bounding boxes
        dx = max(0, max(bounds1[0] - bounds2[2], bounds2[0] - bounds1[2]))
        dy = max(0, max(bounds1[1] - bounds2[3], bounds2[1] - bounds1[3]))
        bbox_min_distance = (dx * dx + dy * dy) ** 0.5

        # SAFE EARLY EXIT: Only skip geometric check if bounding boxes are clearly far apart
        if bbox_min_distance > 50:  # –¢–æ–ª—å–∫–æ –µ—Å–ª–∏ —Ç–æ—á–Ω–æ –¥–∞–ª–µ–∫–æ
            return False

        # ALWAYS do accurate geometric distance check for close/potentially colliding objects
        geometric_distance = polygon1.distance(polygon2)
        return geometric_distance < min_gap

    except Exception:
        # Be conservative on errors
        return True


def check_collision(
    polygon1: Polygon, polygon2: Polygon, min_gap: float = 10.0
) -> bool:
    """Check if two polygons collide using TRUE GEOMETRIC distance with speed optimization.

    min_gap=10.0mm —á—Ç–æ–±—ã –∫–æ–º–ø–µ–Ω—Å–∏—Ä–æ–≤–∞—Ç—å –ø–æ–≥—Ä–µ—à–Ω–æ—Å—Ç—å –ø—Ä–∏ —ç–∫—Å–ø–æ—Ä—Ç–µ SPLINE entities –≤ DXF.
    """
    return check_collision_fast(polygon1, polygon2, min_gap)


# @profile
def bin_packing_with_existing(
    polygons: list[Carpet],
    existing_placed: list[PlacedCarpet],
    sheet_size: tuple[float, float],
    verbose: bool = True,
    tighten=True,
) -> tuple[list[PlacedCarpet], list[UnplacedCarpet]]:
    """Bin packing that considers already placed polygons on the sheet."""
    # Convert sheet size from cm to mm to match DXF polygon units
    sheet_width_mm, sheet_height_mm = sheet_size[0] * 10, sheet_size[1] * 10

    placed: list[PlacedCarpet] = []
    unplaced: list[UnplacedCarpet] = []

    # Start with existing placed polygons as obstacles
    obstacles = [placed_tuple.polygon for placed_tuple in existing_placed]

    # IMPROVEMENT 1: Sort polygons by area and perimeter for better packing
    def get_polygon_priority(polygon_tuple: Carpet):
        polygon = polygon_tuple.polygon
        # Combine area and perimeter for better sorting (larger, more complex shapes first)
        area = polygon.area
        bounds = polygon.bounds
        perimeter_approx = 2 * ((bounds[2] - bounds[0]) + (bounds[3] - bounds[1]))
        return area + perimeter_approx * 0.1

    sorted_polygons = sorted(polygons, key=get_polygon_priority, reverse=True)

    for i, carpet in enumerate(sorted_polygons):
        polygon = carpet.polygon

        placed_successfully = False

        # Check if polygon is too large for the sheet
        bounds = polygon.bounds
        poly_width = bounds[2] - bounds[0]
        poly_height = bounds[3] - bounds[1]

        if poly_width > sheet_width_mm or poly_height > sheet_height_mm:
            unplaced.append(UnplacedCarpet.from_carpet(carpet))
            continue

        # REVOLUTIONARY: Try all rotations with TETRIS PRIORITY (bottom-left first)
        best_placement = None
        best_priority = float("inf")  # Lower is better (Y*1000 + X)

        # –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ —É–≥–ª—ã –¥–ª—è —Ä–µ–∑–∫–∏ (0¬∞, 90¬∞, 180¬∞, 270¬∞)
        rotation_angles = [0, 90, 180, 270]

        for angle in rotation_angles:
            rotated = get_cached_rotation(carpet, angle)
            rotated_bounds = rotated.bounds
            rotated_width = rotated_bounds[2] - rotated_bounds[0]
            rotated_height = rotated_bounds[3] - rotated_bounds[1]

            # Skip if doesn't fit
            if rotated_width > sheet_width_mm or rotated_height > sheet_height_mm:
                continue

            # Find position using Tetris gravity algorithm
            best_x, best_y = find_bottom_left_position_with_obstacles(
                rotated, obstacles, sheet_width_mm, sheet_height_mm
            )

            if best_x is not None and best_y is not None:
                # TRUE TETRIS STRATEGY: Minimize global maximum height, not individual positions!

                # Calculate what the maximum height would be after placing this carpet
                dx_to_target = best_x - rotated_bounds[0]
                dy_to_target = best_y - rotated_bounds[1]
                test_translated = translate_polygon(rotated, dx_to_target, dy_to_target)

                all_test_placed = (
                    existing_placed
                    + placed
                    + [
                        PlacedCarpet(
                            polygon=test_translated,
                            carpet_id=carpet.carpet_id,  # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ä–µ–∞–ª—å–Ω—ã–π carpet_id –≤–º–µ—Å—Ç–æ 0!
                            priority=carpet.priority,
                            x_offset=dx_to_target,
                            y_offset=dy_to_target,
                            angle=angle,
                            filename=carpet.filename,
                            color=carpet.color,
                            order_id=carpet.order_id,
                        )
                    ]
                )

                # Find maximum height after this placement - THIS IS THE KEY TETRIS METRIC!
                max_height_after = (
                    max(c.polygon.bounds[3] for c in all_test_placed)
                    if all_test_placed
                    else 0
                )

                # PRIMARY SCORE: –£–º–µ—Ä–µ–Ω–Ω—ã–π —à—Ç—Ä–∞—Ñ –∑–∞ —É–≤–µ–ª–∏—á–µ–Ω–∏–µ –≤—ã—Å–æ—Ç—ã
                # –ò–ó–ú–ï–ù–ï–ù–û: –£–º–µ–Ω—å—à–µ–Ω –º–Ω–æ–∂–∏—Ç–µ–ª—å –¥–ª—è —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è —Ä–∞–∑–º–µ—â–µ–Ω–∏—è –≤ –≤–µ—Ä—Ö–Ω–∏—Ö –∫–∞—Ä–º–∞–Ω–∞—Ö
                # –í–º–µ—Å—Ç–æ –∂—ë—Å—Ç–∫–æ–π –º–∏–Ω–∏–º–∏–∑–∞—Ü–∏–∏ –≤—ã—Å–æ—Ç—ã, –ø—Ä–∏–æ—Ä–∏—Ç–∏–∑–∏—Ä—É–µ–º –ª–æ–∫–∞–ª—å–Ω—É—é –ø–ª–æ—Ç–Ω–æ—Å—Ç—å
                global_height_score = (
                    max_height_after * 1000  # –£–º–µ–Ω—å—à–µ–Ω–æ —Å 5000 –¥–æ 1000
                )  # –ü–æ–∑–≤–æ–ª—è–µ—Ç —Ä–∞–∑–º–µ—â–∞—Ç—å –∫–æ–≤—Ä—ã –≤ –≤–µ—Ä—Ö–Ω–µ–π —á–∞—Å—Ç–∏ –ø—Ä–∏ –≤—ã—Å–æ–∫–æ–π –∑–∞–ø–æ–ª–Ω–µ–Ω–Ω–æ—Å—Ç–∏

                # SECONDARY SCORE: X position for tie-breaking (prefer left placement)
                x_position_score = best_x

                # –î–ª—è —Å–æ–≤—Å–µ–º –º–∞–ª—ã—Ö –ª–∏—Å—Ç–æ–≤ (1-2 –∫–æ–≤—Ä–∞) –ù–ï –º–∏–Ω–∏–º–∏–∑–∏—Ä—É–µ–º —à–∏—Ä–∏–Ω—É
                # —Ç–∞–∫ –∫–∞–∫ —ç—Ç–æ –±–ª–æ–∫–∏—Ä—É–µ—Ç –ø—Ä–∞–≤–∏–ª—å–Ω–æ–µ —Ä–∞–∑–º–µ—â–µ–Ω–∏–µ —É –∫—Ä–∞–µ–≤
                # –í–º–µ—Å—Ç–æ —ç—Ç–æ–≥–æ –ø–æ–ª–∞–≥–∞–µ–º—Å—è –Ω–∞ scoring –≤ find_bottom_left_position
                position_score = global_height_score + x_position_score

                # –£–õ–£–ß–®–ï–ù–ù–´–ô –¢–ï–¢–†–ò–°: –ë–æ–ª–µ–µ —á—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–∞—è –æ—Ü–µ–Ω–∫–∞ aspect ratio
                shape_bonus = 0
                aspect_ratio = (
                    rotated_width / rotated_height if rotated_height > 0 else 1
                )

                # REDUCED bonus for horizontal orientations - don't override good positions
                if aspect_ratio > 1.05:
                    # Much smaller bonus for width - max 500 instead of 2000
                    width_bonus = min(500, int((aspect_ratio - 1) * 500))
                    shape_bonus -= width_bonus

                    # Extra bonus if touching bottom edge (still important for tetris)
                    if best_y < 5:  # Within 5mm of bottom
                        shape_bonus -= 2000  # Reduced from 3000

                    # Extra bonus if touching left edge (less important than bottom)
                    if best_x < 5:  # Within 5mm of left
                        shape_bonus -= 1000  # Reduced from 2000

                # REDUCED penalty for tall orientations - don't punish good positions too much
                elif aspect_ratio < 0.95:
                    height_penalty = min(
                        300, int((1 - aspect_ratio) * 300)
                    )  # Reduced from 1000
                    shape_bonus += height_penalty

                # REVOLUTIONARY: True tetris quality assessment
                tetris_bonus = calculate_tetris_quality_bonus(
                    rotated, all_test_placed, sheet_width_mm, sheet_height_mm
                )
                shape_bonus -= tetris_bonus  # Negative is better

                # –ö–†–ò–¢–ò–ß–ï–°–ö–ò–ô ANTI-HANGING: –®—Ç—Ä–∞—Ñ—É–µ–º "–≤–∏—Å—è—â–∏–µ" —Ä–∞–∑–º–µ—â–µ–Ω–∏—è –¥–ª—è –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–π —Ç–µ—Ç—Ä–∏—Å–æ–≤–æ—Å—Ç–∏
                # –ö–æ–≤—Ä—ã –î–û–õ–ñ–ù–´ –æ–ø–∏—Ä–∞—Ç—å—Å—è –Ω–∞ –¥–Ω–æ –∏–ª–∏ –¥—Ä—É–≥–∏–µ –∫–æ–≤—Ä—ã, –∏–Ω–∞—á–µ –±–ª–æ–∫–∏—Ä—É—é—Ç –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ
                test_bounds = test_translated.bounds
                bottom_y = test_bounds[1]

                # –£–°–ò–õ–ï–ù–ù–´–ô –®–¢–†–ê–§: –¥–∞–∂–µ –Ω–µ–±–æ–ª—å—à–∞—è –≤—ã—Å–æ—Ç–∞ –æ—Ç –¥–Ω–∞ –¥–æ–ª–∂–Ω–∞ —à—Ç—Ä–∞—Ñ–æ–≤–∞—Ç—å—Å—è
                if (
                    bottom_y > 50
                ):  # –°–Ω–∏–∂–µ–Ω –ø–æ—Ä–æ–≥ —Å 100 –¥–æ 50 –¥–ª—è –±–æ–ª–µ–µ —Å—Ç—Ä–æ–≥–æ–π –∫–æ–º–ø–∞–∫—Ç–Ω–æ—Å—Ç–∏
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–ª–æ—â–∞–¥—å –æ–ø–æ—Ä—ã —Å–Ω–∏–∑—É
                    support_area = 0
                    for other in placed:
                        if other.polygon.bounds[3] <= bottom_y + 5:  # –ö–æ–≤–µ—Ä —Å–Ω–∏–∑—É
                            # –°–æ–∑–¥–∞–µ–º –ø–æ–ª–∏–≥–æ–Ω —á—É—Ç—å –Ω–∏–∂–µ —Ç–µ–∫—É—â–µ–≥–æ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –æ–ø–æ—Ä—ã
                            support_test = translate_polygon(test_translated, 0, -3)
                            if support_test.intersects(other.polygon):
                                intersection = support_test.intersection(other.polygon)
                                support_area += intersection.area

                    # –ï—Å–ª–∏ –æ–ø–æ—Ä–∞ –º–∞–ª–µ–Ω—å–∫–∞—è, —ç—Ç–æ "–≤–∏—Å—è—â–∏–π" –∫–æ–≤–µ—Ä - –ö–†–ò–¢–ò–ß–ï–°–ö–ò–ô —à—Ç—Ä–∞—Ñ
                    carpet_area = test_translated.area
                    support_ratio = support_area / carpet_area if carpet_area > 0 else 0

                    # –ò–ó–ú–ï–ù–ï–ù–û: –£–º–µ—Ä–µ–Ω–Ω—ã–π —à—Ç—Ä–∞—Ñ –∑–∞ –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω—É—é –æ–ø–æ—Ä—É
                    # –†–∞–∑—Ä–µ—à–∞–µ–º —Ä–∞–∑–º–µ—â–µ–Ω–∏–µ –≤ –≤–µ—Ä—Ö–Ω–∏—Ö –∫–∞—Ä–º–∞–Ω–∞—Ö –ø—Ä–∏ —Ö–æ—Ä–æ—à–µ–π –ª–æ–∫–∞–ª—å–Ω–æ–π –ø–ª–æ—Ç–Ω–æ—Å—Ç–∏
                    if support_ratio < 0.4:
                        # –£–º–µ—Ä–µ–Ω–Ω—ã–π —à—Ç—Ä–∞—Ñ –≤–º–µ—Å—Ç–æ –æ–≥—Ä–æ–º–Ω–æ–≥–æ (–±—ã–ª–æ 150000)
                        # –≠—Ç–æ –ø–æ–∑–≤–æ–ª—è–µ—Ç —Ä–∞–∑–º–µ—â–∞—Ç—å –∫–æ–≤—Ä—ã –≤ –≤–µ—Ä—Ö–Ω–∏—Ö –∫–∞—Ä–º–∞–Ω–∞—Ö –º–µ–∂–¥—É –¥—Ä—É–≥–∏–º–∏ –∫–æ–≤—Ä–∞–º–∏
                        hanging_penalty = int(
                            (0.4 - support_ratio) * 10000
                        )  # –£–º–µ–Ω—å—à–µ–Ω–æ —Å 150000
                        shape_bonus += hanging_penalty

                    # –ò–ó–ú–ï–ù–ï–ù–û: –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —à—Ç—Ä–∞—Ñ –∑–∞ –≤—ã—Å–æ—Ç—É, –Ω–µ –±–ª–æ–∫–∏—Ä—É—é—â–∏–π
                    # –£–º–µ–Ω—å—à–µ–Ω–æ —Å 50 –¥–æ 10 –¥–ª—è —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è –≤–µ—Ä—Ö–Ω–µ–≥–æ —Ä–∞–∑–º–µ—â–µ–Ω–∏—è
                    height_penalty = int(bottom_y * 10)  # –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —à—Ç—Ä–∞—Ñ
                    shape_bonus += height_penalty

                total_score = position_score + shape_bonus

                if total_score < best_priority:
                    best_priority = total_score

                    # Calculate proper offsets from original carpet position
                    orig_bounds = carpet.polygon.bounds
                    dx_to_target = best_x - rotated_bounds[0]
                    dy_to_target = best_y - rotated_bounds[1]
                    translated = translate_polygon(rotated, dx_to_target, dy_to_target)

                    # Calculate actual offset from original position
                    final_bounds = translated.bounds
                    actual_x_offset = final_bounds[0] - orig_bounds[0]
                    actual_y_offset = final_bounds[1] - orig_bounds[1]

                    best_placement = {
                        "polygon": translated,
                        "x_offset": actual_x_offset,
                        "y_offset": actual_y_offset,
                        "angle": angle,
                    }

        # Apply best placement if found
        if best_placement:
            placed.append(
                PlacedCarpet(
                    polygon=best_placement["polygon"],
                    carpet_id=carpet.carpet_id,
                    priority=carpet.priority,
                    x_offset=best_placement["x_offset"],
                    y_offset=best_placement["y_offset"],
                    angle=best_placement["angle"],
                    filename=carpet.filename,
                    color=carpet.color,
                    order_id=carpet.order_id,
                )
            )

            # üöÄ –†–ï–í–û–õ–Æ–¶–ò–û–ù–ù–ê–Ø TETRIS-–û–ü–¢–ò–ú–ò–ó–ê–¶–ò–Ø: –ì—Ä–∞–≤–∏—Ç–∞—Ü–∏—è + –°–∂–∞—Ç–∏–µ –∫ –∫—Ä–∞—è–º
            if len(placed) > 1:  # –ù–µ—Å–∫–æ–ª—å–∫–æ –Ω–æ–≤—ã—Ö –∫–æ–≤—Ä–æ–≤
                try:
                    # –≠—Ç–∞–ø 1: –ì—Ä–∞–≤–∏—Ç–∞—Ü–∏—è
                    gravity_placed = apply_tetris_gravity(
                        placed, sheet_width_mm, sheet_height_mm
                    )

                    # –≠—Ç–∞–ø 2: –°–∂–∞—Ç–∏–µ –∫ –ø—Ä–∞–≤–æ–º—É –∫—Ä–∞—é
                    right_placed = apply_tetris_right_compaction(
                        gravity_placed, sheet_width_mm, sheet_height_mm
                    )

                    # –≠—Ç–∞–ø 3: –§–∏–Ω–∞–ª—å–Ω–∞—è –≥—Ä–∞–≤–∏—Ç–∞—Ü–∏—è
                    improved_placed = apply_tetris_gravity(
                        right_placed, sheet_width_mm, sheet_height_mm
                    )

                    # –ö–†–ò–¢–ò–ß–ù–û: –£–ª—å—Ç—Ä–∞-—Å—Ç—Ä–æ–≥–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–ª–ª–∏–∑–∏–π
                    safe = True
                    for i, _ in enumerate(improved_placed):
                        for j in range(i + 1, len(improved_placed)):
                            if check_collision(
                                improved_placed[i].polygon,
                                improved_placed[j].polygon,
                                min_gap=10.0,  # –°—Ç—Ä–æ–≥–∏–π 2–º–º –∑–∞–∑–æ—Ä
                            ):
                                safe = False
                                break
                        if not safe:
                            break

                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–ª–ª–∏–∑–∏–∏ —Å —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–º–∏ –∫–æ–≤—Ä–∞–º–∏
                    if safe:
                        for new_carpet in improved_placed:
                            for existing_carpet in existing_placed:
                                if new_carpet.polygon.intersects(
                                    existing_carpet.polygon
                                ):
                                    intersection = new_carpet.polygon.intersection(
                                        existing_carpet.polygon
                                    )
                                    if intersection.area > 50:
                                        safe = False
                                        break
                            if not safe:
                                break

                    if safe:
                        placed = improved_placed

                except Exception:
                    pass  # –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –æ—à–∏–±–∫–∏ –≥—Ä–∞–≤–∏—Ç–∞—Ü–∏–∏

            # –î–æ–±–∞–≤–ª—è–µ–º –∫–∞–∫ –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–µ –¥–ª—è —Å–ª–µ–¥—É—é—â–∏—Ö –∫–æ–≤—Ä–æ–≤
            obstacles.append(best_placement["polygon"])

            placed_successfully = True

        if not placed_successfully:
            unplaced.append(UnplacedCarpet.from_carpet(carpet))

    # FAST OPTIMIZATION for existing sheets
    if tighten and len(placed) <= 5:  # Very conservative optimization
        # Apply simple compaction only for tiny sets
        placed = simple_compaction(placed, sheet_size)

        # Light tightening with obstacles
        all_obstacles = existing_placed + placed
        placed = tighten_layout_with_obstacles(
            placed, all_obstacles, sheet_size, min_gap=1.0
        )

    return placed, unplaced


def ultra_left_compaction(
    placed: list[PlacedCarpet],
    sheet_size: tuple[float, float],
    target_width_fraction: float = 0.7,  # Try to fit everything in 70% of sheet width
) -> list[PlacedCarpet]:
    """ULTRA-AGGRESSIVE left compaction - squeeze everything to the left side."""
    if not placed:
        return placed

    sheet_width_mm = sheet_size[0] * 10
    target_width = sheet_width_mm * target_width_fraction

    current_polys = [item.polygon for item in placed]
    meta = placed[:]
    n = len(current_polys)

    # Ultra-aggressive left push - try to fit all in left portion
    for iteration in range(3):  # Multiple passes for maximum effect
        moved_any = False

        # Sort by current X position (process rightmost first)
        x_order = sorted(range(n), key=lambda i: -current_polys[i].bounds[0])

        for i in x_order:
            poly = current_polys[i]
            bounds = poly.bounds

            # Calculate how far left we can push this polygon
            current_right = bounds[2]
            desired_right = target_width  # Want to fit in target area

            if current_right > desired_right:
                # Calculate how much we need to move left
                required_move = current_right - desired_right
                max_possible_move = bounds[0]  # Can't go beyond left edge

                # Try to move as much as needed, but not beyond possible
                move_distance = min(required_move, max_possible_move)

                # Try progressive distances
                for distance in [
                    move_distance,
                    move_distance * 0.75,
                    move_distance * 0.5,
                    move_distance * 0.25,
                    10.0,
                    5.0,
                    2.0,
                    1.0,
                ]:
                    if distance < 0.5:
                        continue

                    test = translate_polygon(poly, -distance, 0)
                    if test.bounds[0] < 0:  # Don't go beyond left edge
                        continue

                    # Check collisions
                    collision = False
                    for j in range(n):
                        if j != i and test.intersects(current_polys[j]):
                            collision = True
                            break

                    if not collision:
                        current_polys[i] = test
                        moved_any = True
                        break

        if not moved_any:
            break

    # Create result
    new_placed = []
    for i in range(n):
        new_poly = current_polys[i]
        orig_poly = placed[i].polygon

        dx_total = new_poly.bounds[0] - orig_poly.bounds[0]
        dy_total = new_poly.bounds[1] - orig_poly.bounds[1]

        item = meta[i]
        new_placed.append(
            PlacedCarpet(
                polygon=new_poly,
                carpet_id=item.carpet_id,
                priority=item.priority,
                x_offset=item.x_offset + dx_total,
                y_offset=item.y_offset + dy_total,
                angle=item.angle,
                filename=item.filename,
                color=item.color,
                order_id=item.order_id,
            )
        )

    return new_placed


def simple_compaction(
    placed: list[PlacedCarpet], sheet_size: tuple[float, float], min_gap: float = 0.5
) -> list[PlacedCarpet]:
    """FAST Simple compaction - just basic left+down movement."""
    if not placed or len(placed) > 35:  # Allow processing of larger sets
        return placed

    current_polys = [item.polygon for item in placed]
    meta = placed[:]
    n = len(current_polys)

    moved_any = True
    max_passes = 1  # Reduced from 2 for speed

    for pass_num in range(max_passes):
        if not moved_any:
            break
        moved_any = False

        # Simple down movement
        for i in range(n):
            poly = current_polys[i]
            step = 3.0  # Increased from 2.0 for speed

            while True:
                test = translate_polygon(poly, 0, -step)
                if test.bounds[1] < 0:
                    break

                # Collision check with min_gap
                collision = False
                for j in range(n):
                    if j != i:
                        # Check both intersection and minimum gap
                        if (
                            test.intersects(current_polys[j])
                            or test.distance(current_polys[j]) < min_gap
                        ):
                            collision = True
                            break

                if collision:
                    break

                current_polys[i] = test
                poly = test
                moved_any = True

        # AGGRESSIVE LEFT MOVEMENT - push as far left as possible
        x_order = sorted(
            range(n), key=lambda i: current_polys[i].bounds[0]
        )  # Process left to right

        for i in x_order:
            poly = current_polys[i]
            bounds = poly.bounds

            # Calculate maximum possible left movement
            max_left_move = bounds[0]  # Distance to left edge

            # Try to move maximum distance first, then smaller steps
            for left_distance in [
                max_left_move,
                max_left_move * 0.75,
                max_left_move * 0.5,
                max_left_move * 0.25,
                5.0,
                2.0,
                1.0,
            ]:
                if left_distance < 0.5:  # Skip tiny movements
                    continue

                test = translate_polygon(poly, -left_distance, 0)
                if test.bounds[0] < 0:  # Don't go beyond left edge
                    continue

                collision = False
                for j in range(n):
                    if j != i:
                        # Check both intersection and minimum gap
                        if (
                            test.intersects(current_polys[j])
                            or test.distance(current_polys[j]) < min_gap
                        ):
                            collision = True
                            break

                if not collision:
                    current_polys[i] = test
                    moved_any = True
                    break  # Found best position, move to next polygon

    # Create result
    new_placed = []
    for i in range(n):
        new_poly = current_polys[i]
        orig_poly = placed[i].polygon

        dx_total = new_poly.bounds[0] - orig_poly.bounds[0]
        dy_total = new_poly.bounds[1] - orig_poly.bounds[1]

        item = meta[i]
        new_placed.append(
            PlacedCarpet(
                polygon=new_poly,
                carpet_id=item.carpet_id,
                priority=item.priority,
                x_offset=item.x_offset + dx_total,
                y_offset=item.y_offset + dy_total,
                angle=item.angle,
                filename=item.filename,
                color=item.color,
                order_id=item.order_id,
            )
        )

    return new_placed


def fast_edge_snap(
    placed: list[PlacedCarpet], sheet_size: tuple[float, float], min_gap: float = 1.0
) -> list[PlacedCarpet]:
    """FAST edge snapping - just basic left/bottom movement."""
    if not placed or len(placed) > 25:  # Allow larger sets for better optimization
        return placed

    current_polys = [item.polygon for item in placed]
    meta = placed[:]
    n = len(current_polys)

    max_iterations = 2  # Very limited iterations

    for iteration in range(max_iterations):
        moved_any = False

        # Simple movement - try to move each polygon left and down
        for i in range(n):
            poly = current_polys[i]

            # Try to move down
            step = 5.0  # Large step for speed
            test = translate_polygon(poly, 0, -step)
            if test.bounds[1] >= 0:
                # Quick collision check - only intersections
                collision = False
                for j in range(n):
                    if j != i and test.intersects(current_polys[j]):
                        collision = True
                        break

                if not collision:
                    current_polys[i] = test
                    moved_any = True
                    poly = test

            # AGGRESSIVE LEFT PUSH - move as far left as possible
            bounds = poly.bounds
            max_left = bounds[0]  # Maximum distance we can move left

            # Try progressively smaller left movements for maximum compaction
            for left_distance in [
                max_left,
                max_left * 0.75,
                max_left * 0.5,
                max_left * 0.25,
                step,
                step / 2,
            ]:
                if left_distance < 0.5:
                    continue

                test = translate_polygon(poly, -left_distance, 0)
                if test.bounds[0] < 0:
                    continue

                collision = False
                for j in range(n):
                    if j != i and test.intersects(current_polys[j]):
                        collision = True
                        break

                if not collision:
                    current_polys[i] = test
                    moved_any = True
                    break  # Found best left position

        if not moved_any:
            break

    # Create result list
    new_placed: list[PlacedCarpet] = []

    for i in range(n):
        new_poly = current_polys[i]
        orig_poly = placed[i].polygon

        # Calculate total displacement
        dx_total = new_poly.bounds[0] - orig_poly.bounds[0]
        dy_total = new_poly.bounds[1] - orig_poly.bounds[1]

        item = meta[i]
        new_x_off = item.x_offset + dx_total
        new_y_off = item.y_offset + dy_total

        new_placed.append(
            PlacedCarpet(
                polygon=new_poly,
                carpet_id=item.carpet_id,
                priority=item.priority,
                x_offset=new_x_off,
                y_offset=new_y_off,
                angle=item.angle,
                filename=item.filename,
                color=item.color,
                order_id=item.order_id,
            )
        )

    return new_placed


def bin_packing(
    polygons: list[Carpet],
    sheet_size: tuple[float, float],
    verbose: bool = True,
    progress_callback=None,  # Callback function for progress updates
) -> tuple[list[PlacedCarpet], list[UnplacedCarpet]]:
    """Optimize placement of complex polygons on a sheet with ultra-dense/polygonal/improved algorithms."""

    # Performance timing (no algorithm changes)

    # Convert sheet size from cm to mm to match DXF polygon units
    sheet_width_mm, sheet_height_mm = sheet_size[0] * 10, sheet_size[1] * 10

    placed: list[PlacedCarpet] = []
    unplaced: list[UnplacedCarpet] = []

    # IMPROVEMENT 1: Enhanced polygon sorting for optimal packing density
    def get_polygon_priority(carpet: Carpet):
        polygon = carpet.polygon
        area = polygon.area
        bounds = polygon.bounds
        width = bounds[2] - bounds[0]
        height = bounds[3] - bounds[1]

        # Multi-factor scoring for better packing:
        # 1. Priority level (priority 1 always comes first)
        # 2. Area (larger first within same priority)
        # 3. Aspect ratio (irregular shapes first)
        # 4. Compactness (less regular shapes first)
        aspect_ratio = (
            max(width / height, height / width) if min(width, height) > 0 else 1
        )
        compactness = area / (width * height) if width * height > 0 else 0
        perimeter_approx = 2 * (width + height)

        # Base score from geometry
        geometry_score = (
            area * 1.0
            + (aspect_ratio - 1) * area * 0.3
            + (1 - compactness) * area * 0.2
            + perimeter_approx * 0.05
        )
        return geometry_score

    sorted_polygons = sorted(polygons, key=get_polygon_priority, reverse=True)

    # Set dataset size context for adaptive algorithms
    find_bottom_left_position._dataset_size = len(sorted_polygons)

    # PERFORMANCE: Adaptive processing - –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –≤—Å–µ—Ö –∫–æ–≤—Ä–æ–≤
    def should_process_carpet(index, total_count, placed_count):
        """
        –û–ø—Ä–µ–¥–µ–ª–∏—Ç—å, –Ω—É–∂–Ω–æ –ª–∏ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å –∫–æ–≤–µ—Ä —Å –¥–∞–Ω–Ω—ã–º –∏–Ω–¥–µ–∫—Å–æ–º.
        –ò–°–ü–†–ê–í–õ–ï–ù–û: –û–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç –æ–±—Ä–∞–±–æ—Ç–∫—É –≤—Å–µ—Ö –∫–æ–≤—Ä–æ–≤, –∏–∑–±–µ–≥–∞—è "–ø–æ—Ç–µ—Ä–∏" –æ—Å—Ç–∞—Ç–∫–æ–≤.
        """
        # –ö–†–ò–¢–ò–ß–ù–û: –î–ª—è –º–∞–ª—ã—Ö –Ω–∞–±–æ—Ä–æ–≤ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –í–°–ï
        if total_count <= 70:
            return True

        # –ê–¥–∞–ø—Ç–∏–≤–Ω–∞—è –ª–æ–≥–∏–∫–∞ –¥–ª—è –±–æ–ª—å—à–∏—Ö –Ω–∞–±–æ—Ä–æ–≤
        fill_ratio = placed_count / max(1, total_count * 0.1)

        if fill_ratio < 0.3:  # –ü–æ—á—Ç–∏ –ø—É—Å—Ç–æ–π –ª–∏—Å—Ç - –±–æ–ª—å—à–µ –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤
            target_count = min(70, total_count)
        else:  # –ü–æ—á—Ç–∏ –ø–æ–ª–æ–Ω - –º–µ–Ω—å—à–µ –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤
            target_count = min(50, total_count)

        # –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ë–µ–∑–æ–ø–∞—Å–Ω—ã–π —Ä–∞—Å—á–µ—Ç —à–∞–≥–∞
        if target_count >= total_count:
            return True  # –ï—Å–ª–∏ —Ü–µ–ª—å >= –æ–±—â–µ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ - –±–µ—Ä–µ–º –≤—Å–µ

        step = max(1, total_count // target_count)

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –ø–æ–ø–∞–¥–∞–µ—Ç –ª–∏ —Ç–µ–∫—É—â–∏–π –∏–Ω–¥–µ–∫—Å –≤ —Ä–∞–≤–Ω–æ–º–µ—Ä–Ω—É—é –≤—ã–±–æ—Ä–∫—É
        return index % step == 0

    total_carpet_count = len(sorted_polygons)
    processed_count = 0

    for i, carpet in enumerate(sorted_polygons):
        # PERFORMANCE: –ë—ã—Å—Ç—Ä–æ –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –Ω–µ–Ω—É–∂–Ω—ã–µ –∫–æ–≤—Ä—ã
        if not should_process_carpet(i, total_carpet_count, len(placed)):
            continue

        processed_count += 1
        placed_successfully = False

        # Check if polygon is too large for the sheet
        bounds = carpet.polygon.bounds
        poly_width = bounds[2] - bounds[0]
        poly_height = bounds[3] - bounds[1]

        if poly_width > sheet_width_mm or poly_height > sheet_height_mm:
            unplaced.append(UnplacedCarpet.from_carpet(carpet))
            continue

        # REVOLUTIONARY TETRIS ROTATION STRATEGY: Optimize for space liberation
        best_placement = None
        best_score = float("inf")  # Lower is better

        # –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ —É–≥–ª—ã –¥–ª—è —Ä–µ–∑–∫–∏ (0¬∞, 90¬∞, 180¬∞, 270¬∞)
        rotation_angles = [0, 90, 180, 270]

        # –ü–†–ò–û–†–ò–¢–ï–¢ –û–î–ò–ù–ê–ö–û–í–û–ì–û –£–ì–õ–ê: –î–ª—è –æ–¥–∏–Ω–∞–∫–æ–≤—ã—Ö –∫–æ–≤—Ä–æ–≤ —Å–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–±—É–µ–º —Ç–æ—Ç –∂–µ —É–≥–æ–ª
        # –≠—Ç–æ –æ–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç –ø–ª–æ—Ç–Ω—É—é —É–ø–∞–∫–æ–≤–∫—É - –æ–¥–∏–Ω–∞–∫–æ–≤—ã–µ —Ñ–æ—Ä–º—ã –ª—É—á—à–µ —Å—Ç—ã–∫—É—é—Ç—Å—è
        same_carpets_placed = [p for p in placed if p.filename == carpet.filename]
        if len(same_carpets_placed) > 0:
            # –°–º–æ—Ç—Ä–∏–º –∫–∞–∫–∏–µ —É–≥–ª—ã —É–∂–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω—ã
            used_angles = [p.angle for p in same_carpets_placed]

            # –ù–∞—Ö–æ–¥–∏–º —Å–∞–º—ã–π –ø–æ–ø—É–ª—è—Ä–Ω—ã–π —É–≥–æ–ª —Å—Ä–µ–¥–∏ —É–∂–µ —Ä–∞–∑–º–µ—â–µ–Ω–Ω—ã—Ö –æ–¥–∏–Ω–∞–∫–æ–≤—ã—Ö –∫–æ–≤—Ä–æ–≤
            angle_counts = {a: used_angles.count(a) for a in [0, 90, 180, 270]}
            most_common_angle = max(angle_counts.items(), key=lambda x: x[1])[0]

            # –ü—Ä–æ–±—É–µ–º —Å–Ω–∞—á–∞–ª–∞ —Å–∞–º—ã–π –ø–æ–ø—É–ª—è—Ä–Ω—ã–π —É–≥–æ–ª, –ø–æ—Ç–æ–º –≤—Å–µ –æ—Å—Ç–∞–ª—å–Ω—ã–µ
            # –≠—Ç–æ –¥–∞—ë—Ç –ø–ª–æ—Ç–Ω—É—é —É–ø–∞–∫–æ–≤–∫—É: –æ–¥–∏–Ω–∞–∫–æ–≤—ã–µ –∫–æ–≤—Ä—ã –ø–æ–¥ –æ–¥–Ω–∏–º —É–≥–ª–æ–º —Å—Ç—ã–∫—É—é—Ç—Å—è –ª—É—á—à–µ
            rotation_angles = [most_common_angle] + [
                a for a in [0, 90, 180, 270] if a != most_common_angle
            ]

        for angle in rotation_angles:
            rotated = get_cached_rotation(carpet, angle)
            rotated_bounds = rotated.bounds
            rotated_width = rotated_bounds[2] - rotated_bounds[0]
            rotated_height = rotated_bounds[3] - rotated_bounds[1]

            # Skip if doesn't fit
            if rotated_width > sheet_width_mm or rotated_height > sheet_height_mm:
                continue

            # –ß–ò–°–¢–´–ô BOTTOM-LEFT: —Ä–∞–∑–º–µ—â–∞–µ–º –≤ —Å–∞–º–æ–π –Ω–∏–∂–Ω–µ–π-–ª–µ–≤–æ–π –ø–æ–∑–∏—Ü–∏–∏
            bl_x, bl_y = find_bottom_left_position(
                rotated, placed, sheet_width_mm, sheet_height_mm
            )
            if bl_x is None or bl_y is None:
                continue

            # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç–æ–ª—å–∫–æ –æ–¥–Ω—É –ø–æ–∑–∏—Ü–∏—é - bottom-left
            candidate_positions = [(bl_x, bl_y)]

            # –ü—Ä–æ–±—É–µ–º —ç—Ç—É –ø–æ–∑–∏—Ü–∏—é
            for best_x, best_y in candidate_positions:
                # TRUE TETRIS STRATEGY: Minimize global maximum height, not individual positions!

                # Calculate what the maximum height would be after placing this carpet
                dx_to_target = best_x - rotated_bounds[0]
                dy_to_target = best_y - rotated_bounds[1]
                test_translated = translate_polygon(rotated, dx_to_target, dy_to_target)

                all_test_placed = placed + [
                    PlacedCarpet(
                        polygon=test_translated,
                        x_offset=dx_to_target,
                        y_offset=dy_to_target,
                        angle=angle,
                        filename=carpet.filename,
                        color=carpet.color,
                        order_id=carpet.order_id,
                        carpet_id=carpet.carpet_id,
                        priority=carpet.priority,
                    )
                ]

                # Find maximum height after this placement - THIS IS THE KEY TETRIS METRIC!
                max_height_after = (
                    max(c.polygon.bounds[3] for c in all_test_placed)
                    if all_test_placed
                    else 0
                )

                # PRIMARY SCORE: –£–º–µ—Ä–µ–Ω–Ω—ã–π —à—Ç—Ä–∞—Ñ –∑–∞ —É–≤–µ–ª–∏—á–µ–Ω–∏–µ –≤—ã—Å–æ—Ç—ã
                # –ò–ó–ú–ï–ù–ï–ù–û: –£–º–µ–Ω—å—à–µ–Ω –º–Ω–æ–∂–∏—Ç–µ–ª—å –¥–ª—è —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è —Ä–∞–∑–º–µ—â–µ–Ω–∏—è –≤ –≤–µ—Ä—Ö–Ω–∏—Ö –∫–∞—Ä–º–∞–Ω–∞—Ö
                # –í–º–µ—Å—Ç–æ –∂—ë—Å—Ç–∫–æ–π –º–∏–Ω–∏–º–∏–∑–∞—Ü–∏–∏ –≤—ã—Å–æ—Ç—ã, –ø—Ä–∏–æ—Ä–∏—Ç–∏–∑–∏—Ä—É–µ–º –ª–æ–∫–∞–ª—å–Ω—É—é –ø–ª–æ—Ç–Ω–æ—Å—Ç—å
                global_height_score = (
                    max_height_after * 1000  # –£–º–µ–Ω—å—à–µ–Ω–æ —Å 5000 –¥–æ 1000
                )  # –ü–æ–∑–≤–æ–ª—è–µ—Ç —Ä–∞–∑–º–µ—â–∞—Ç—å –∫–æ–≤—Ä—ã –≤ –≤–µ—Ä—Ö–Ω–µ–π —á–∞—Å—Ç–∏ –ø—Ä–∏ –≤—ã—Å–æ–∫–æ–π –∑–∞–ø–æ–ª–Ω–µ–Ω–Ω–æ—Å—Ç–∏

                # SECONDARY SCORE: X position for tie-breaking (prefer left placement)
                x_position_score = best_x

                # –î–ª—è —Å–æ–≤—Å–µ–º –º–∞–ª—ã—Ö –ª–∏—Å—Ç–æ–≤ (1-2 –∫–æ–≤—Ä–∞) –ù–ï –º–∏–Ω–∏–º–∏–∑–∏—Ä—É–µ–º —à–∏—Ä–∏–Ω—É
                # —Ç–∞–∫ –∫–∞–∫ —ç—Ç–æ –±–ª–æ–∫–∏—Ä—É–µ—Ç –ø—Ä–∞–≤–∏–ª—å–Ω–æ–µ —Ä–∞–∑–º–µ—â–µ–Ω–∏–µ —É –∫—Ä–∞–µ–≤
                # –í–º–µ—Å—Ç–æ —ç—Ç–æ–≥–æ –ø–æ–ª–∞–≥–∞–µ–º—Å—è –Ω–∞ scoring –≤ find_bottom_left_position
                position_score = global_height_score + x_position_score

                # –£–õ–£–ß–®–ï–ù–ù–´–ô –¢–ï–¢–†–ò–°: –ë–æ–ª–µ–µ —á—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–∞—è –æ—Ü–µ–Ω–∫–∞ aspect ratio
                shape_bonus = 0
                aspect_ratio = (
                    rotated_width / rotated_height if rotated_height > 0 else 1
                )

                # REDUCED bonus for horizontal orientations - don't override good positions
                if aspect_ratio > 1.05:
                    # Much smaller bonus for width - max 500 instead of 2000
                    width_bonus = min(500, int((aspect_ratio - 1) * 500))
                    shape_bonus -= width_bonus

                    # Extra bonus if touching bottom edge (still important for tetris)
                    if best_y < 5:  # Within 5mm of bottom
                        shape_bonus -= 2000  # Reduced from 3000

                    # Extra bonus if touching left edge (less important than bottom)
                    if best_x < 5:  # Within 5mm of left
                        shape_bonus -= 1000  # Reduced from 2000

                # REDUCED penalty for tall orientations - don't punish good positions too much
                elif aspect_ratio < 0.95:
                    height_penalty = min(
                        300, int((1 - aspect_ratio) * 300)
                    )  # Reduced from 1000
                    shape_bonus += height_penalty

                # üéØ –ú–ê–ö–°–ò–ú–ò–ó–ê–¶–ò–Ø –í–ï–†–•–ù–ï–ì–û –ü–†–û–°–¢–†–ê–ù–°–¢–í–ê: –ö–ª—é—á–µ–≤–∞—è –¢–µ—Ç—Ä–∏—Å-—Å—Ç—Ä–∞—Ç–µ–≥–∏—è
                # –ü—Ä–µ–¥–ø–æ—á–∏—Ç–∞–µ–º –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏–∏ –∫–æ—Ç–æ—Ä—ã–µ –º–∞–∫—Å–∏–º–∏–∑–∏—Ä—É—é—Ç –Ω–µ–ø—Ä–µ—Ä—ã–≤–Ω–æ–µ —Å–≤–æ–±–æ–¥–Ω–æ–µ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ —Å–≤–µ—Ä—Ö—É

                # –°–∏–º—É–ª–∏—Ä—É–µ–º —Ä–∞–∑–º–µ—â–µ–Ω–∏–µ —ç—Ç–æ–≥–æ –∫–æ–≤—Ä–∞ –∏ –≤—ã—á–∏—Å–ª—è–µ–º –±—É–¥—É—â—É—é –º–∞–∫—Å–∏–º–∞–ª—å–Ω—É—é –≤—ã—Å–æ—Ç—É
                # dx_to_target = best_x - rotated_bounds[0]
                # dy_to_target = best_y - rotated_bounds[1]
                # test_translated = translate_polygon(rotated, dx_to_target, dy_to_target)

                # REVOLUTIONARY: True tetris quality assessment
                tetris_bonus = calculate_tetris_quality_bonus(
                    rotated, all_test_placed, sheet_width_mm, sheet_height_mm
                )
                shape_bonus -= tetris_bonus  # Negative is better

                # –ö–†–ò–¢–ò–ß–ï–°–ö–ò–ô ANTI-HANGING: –®—Ç—Ä–∞—Ñ—É–µ–º "–≤–∏—Å—è—â–∏–µ" —Ä–∞–∑–º–µ—â–µ–Ω–∏—è –¥–ª—è –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–π —Ç–µ—Ç—Ä–∏—Å–æ–≤–æ—Å—Ç–∏
                # –ö–æ–≤—Ä—ã –î–û–õ–ñ–ù–´ –æ–ø–∏—Ä–∞—Ç—å—Å—è –Ω–∞ –¥–Ω–æ –∏–ª–∏ –¥—Ä—É–≥–∏–µ –∫–æ–≤—Ä—ã, –∏–Ω–∞—á–µ –±–ª–æ–∫–∏—Ä—É—é—Ç –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ
                test_bounds = test_translated.bounds
                bottom_y = test_bounds[1]

                # –£–°–ò–õ–ï–ù–ù–´–ô –®–¢–†–ê–§: –¥–∞–∂–µ –Ω–µ–±–æ–ª—å—à–∞—è –≤—ã—Å–æ—Ç–∞ –æ—Ç –¥–Ω–∞ –¥–æ–ª–∂–Ω–∞ —à—Ç—Ä–∞—Ñ–æ–≤–∞—Ç—å—Å—è
                if (
                    bottom_y > 50
                ):  # –°–Ω–∏–∂–µ–Ω –ø–æ—Ä–æ–≥ —Å 100 –¥–æ 50 –¥–ª—è –±–æ–ª–µ–µ —Å—Ç—Ä–æ–≥–æ–π –∫–æ–º–ø–∞–∫—Ç–Ω–æ—Å—Ç–∏
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–ª–æ—â–∞–¥—å –æ–ø–æ—Ä—ã —Å–Ω–∏–∑—É
                    support_area = 0
                    for other in placed:
                        if other.polygon.bounds[3] <= bottom_y + 5:  # –ö–æ–≤–µ—Ä —Å–Ω–∏–∑—É
                            # –°–æ–∑–¥–∞–µ–º –ø–æ–ª–∏–≥–æ–Ω —á—É—Ç—å –Ω–∏–∂–µ —Ç–µ–∫—É—â–µ–≥–æ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –æ–ø–æ—Ä—ã
                            support_test = translate_polygon(test_translated, 0, -3)
                            if support_test.intersects(other.polygon):
                                intersection = support_test.intersection(other.polygon)
                                support_area += intersection.area

                    # –ï—Å–ª–∏ –æ–ø–æ—Ä–∞ –º–∞–ª–µ–Ω—å–∫–∞—è, —ç—Ç–æ "–≤–∏—Å—è—â–∏–π" –∫–æ–≤–µ—Ä - –ö–†–ò–¢–ò–ß–ï–°–ö–ò–ô —à—Ç—Ä–∞—Ñ
                    carpet_area = test_translated.area
                    support_ratio = support_area / carpet_area if carpet_area > 0 else 0

                    # –ò–ó–ú–ï–ù–ï–ù–û: –£–º–µ—Ä–µ–Ω–Ω—ã–π —à—Ç—Ä–∞—Ñ –∑–∞ –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω—É—é –æ–ø–æ—Ä—É
                    # –†–∞–∑—Ä–µ—à–∞–µ–º —Ä–∞–∑–º–µ—â–µ–Ω–∏–µ –≤ –≤–µ—Ä—Ö–Ω–∏—Ö –∫–∞—Ä–º–∞–Ω–∞—Ö –ø—Ä–∏ —Ö–æ—Ä–æ—à–µ–π –ª–æ–∫–∞–ª—å–Ω–æ–π –ø–ª–æ—Ç–Ω–æ—Å—Ç–∏
                    if support_ratio < 0.4:
                        # –£–º–µ—Ä–µ–Ω–Ω—ã–π —à—Ç—Ä–∞—Ñ –≤–º–µ—Å—Ç–æ –æ–≥—Ä–æ–º–Ω–æ–≥–æ (–±—ã–ª–æ 150000)
                        # –≠—Ç–æ –ø–æ–∑–≤–æ–ª—è–µ—Ç —Ä–∞–∑–º–µ—â–∞—Ç—å –∫–æ–≤—Ä—ã –≤ –≤–µ—Ä—Ö–Ω–∏—Ö –∫–∞—Ä–º–∞–Ω–∞—Ö –º–µ–∂–¥—É –¥—Ä—É–≥–∏–º–∏ –∫–æ–≤—Ä–∞–º–∏
                        hanging_penalty = int(
                            (0.4 - support_ratio) * 10000
                        )  # –£–º–µ–Ω—å—à–µ–Ω–æ —Å 150000
                        shape_bonus += hanging_penalty

                    # –ò–ó–ú–ï–ù–ï–ù–û: –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —à—Ç—Ä–∞—Ñ –∑–∞ –≤—ã—Å–æ—Ç—É, –Ω–µ –±–ª–æ–∫–∏—Ä—É—é—â–∏–π
                    # –£–º–µ–Ω—å—à–µ–Ω–æ —Å 50 –¥–æ 10 –¥–ª—è —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è –≤–µ—Ä—Ö–Ω–µ–≥–æ —Ä–∞–∑–º–µ—â–µ–Ω–∏—è
                    height_penalty = int(bottom_y * 10)  # –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —à—Ç—Ä–∞—Ñ
                    shape_bonus += height_penalty

                # –ö–†–ò–¢–ò–ß–ï–°–ö–ò –í–ê–ñ–ù–´–ô –ë–û–ù–£–° –ó–ê –ü–†–ê–í–ò–õ–¨–ù–£–Æ –û–†–ò–ï–ù–¢–ê–¶–ò–Æ
                # –î–ª—è —Å–∏–º–º–µ—Ç—Ä–∏—á–Ω—ã—Ö –∫–æ–≤—Ä–æ–≤ - –æ–¥–∏–Ω–∞–∫–æ–≤—ã–π —É–≥–æ–ª
                # –î–ª—è –∞—Å–∏–º–º–µ—Ç—Ä–∏—á–Ω—ã—Ö - —á–µ—Ä–µ–¥—É—é—â–∏–µ—Å—è —É–≥–ª—ã (90¬∞‚Üî270¬∞, 0¬∞‚Üî180¬∞) –¥–ª—è –ª—É—á—à–µ–π —Å—Ç—ã–∫–æ–≤–∫–∏
                orientation_bonus = 0
                if len(same_carpets_placed) > 0:
                    angles_used = [p.angle for p in same_carpets_placed]

                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∞—Å–∏–º–º–µ—Ç—Ä–∏—á–Ω–æ—Å—Ç—å: —Å—Ä–∞–≤–Ω–∏–≤–∞–µ–º —Ü–µ–Ω—Ç—Ä–æ–∏–¥—ã –ø—Ä–∏ 0¬∞ –∏ 180¬∞
                    rot_0 = get_cached_rotation(carpet, 0)
                    rot_180 = get_cached_rotation(carpet, 180)

                    # –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –æ–±–µ —Ñ–æ—Ä–º—ã –∫ –æ–¥–∏–Ω–∞–∫–æ–≤–æ–π –ø–æ–∑–∏—Ü–∏–∏ –¥–ª—è —Å—Ä–∞–≤–Ω–µ–Ω–∏—è
                    bounds_0 = rot_0.bounds
                    bounds_180 = rot_180.bounds

                    # –°–¥–≤–∏–≥–∞–µ–º –æ–±–µ —Ñ–æ—Ä–º—ã –≤ (0,0)
                    from shapely.affinity import translate as shapely_translate

                    norm_0 = shapely_translate(rot_0, -bounds_0[0], -bounds_0[1])
                    norm_180 = shapely_translate(
                        rot_180, -bounds_180[0], -bounds_180[1]
                    )

                    # –°—Ä–∞–≤–Ω–∏–≤–∞–µ–º —Ü–µ–Ω—Ç—Ä–æ–∏–¥—ã –ø–æ—Å–ª–µ –Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏–∏
                    cent_0 = norm_0.centroid
                    cent_180 = norm_180.centroid

                    # –ï—Å–ª–∏ —Ü–µ–Ω—Ç—Ä–æ–∏–¥—ã –æ—Ç–ª–∏—á–∞—é—Ç—Å—è >5% –æ—Ç —Ä–∞–∑–º–µ—Ä–∞ - –∞—Å–∏–º–º–µ—Ç—Ä–∏—á–Ω–∞—è
                    width_0 = bounds_0[2] - bounds_0[0]
                    height_0 = bounds_0[3] - bounds_0[1]
                    max_dim = max(width_0, height_0)

                    cent_diff_x = abs(cent_0.x - cent_180.x)
                    cent_diff_y = abs(cent_0.y - cent_180.y)

                    is_asymmetric = (
                        cent_diff_x > max_dim * 0.05 or cent_diff_y > max_dim * 0.05
                    )

                    if is_asymmetric:
                        # –î–ª—è –∞—Å–∏–º–º–µ—Ç—Ä–∏—á–Ω—ã—Ö: —á–µ—Ä–µ–¥—É–µ–º 90¬∞ –∏ 270¬∞ (–∏–ª–∏ 0¬∞ –∏ 180¬∞)
                        # –ï—Å–ª–∏ –ø–æ—Å–ª–µ–¥–Ω–∏–π –∫–æ–≤–µ—Ä –±—ã–ª 270¬∞, —Ç–µ–∫—É—â–∏–π –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å 90¬∞ (–∏ –Ω–∞–æ–±–æ—Ä–æ—Ç)
                        last_angle = angles_used[-1]

                        if (last_angle == 270 and angle == 90) or (
                            last_angle == 90 and angle == 270
                        ):
                            orientation_bonus = -200000  # –û–ì–†–û–ú–ù–´–ô –±–æ–Ω—É—Å –∑–∞ —á–µ—Ä–µ–¥–æ–≤–∞–Ω–∏–µ
                        elif (last_angle == 0 and angle == 180) or (
                            last_angle == 180 and angle == 0
                        ):
                            orientation_bonus = -200000
                        elif angle == last_angle:
                            # –û–¥–∏–Ω–∞–∫–æ–≤—ã–π —É–≥–æ–ª –¥–ª—è –∞—Å–∏–º–º–µ—Ç—Ä–∏—á–Ω—ã—Ö - –û–ì–†–û–ú–ù–´–ô —à—Ç—Ä–∞—Ñ
                            orientation_bonus = +200000
                    else:
                        # –î–ª—è —Å–∏–º–º–µ—Ç—Ä–∏—á–Ω—ã—Ö: –æ–¥–∏–Ω–∞–∫–æ–≤—ã–π —É–≥–æ–ª
                        if angle in angles_used:
                            count_at_this_angle = angles_used.count(angle)
                            orientation_bonus = -count_at_this_angle * 100000

                shape_bonus += orientation_bonus

                total_score = position_score + shape_bonus

                if total_score < best_score:
                    best_score = total_score

                    # Calculate proper offsets from original carpet position
                    orig_bounds = carpet.polygon.bounds
                    dx_to_target = best_x - rotated_bounds[0]
                    dy_to_target = best_y - rotated_bounds[1]
                    translated = translate_polygon(rotated, dx_to_target, dy_to_target)

                    # Calculate actual offset from original position
                    final_bounds = translated.bounds
                    actual_x_offset = final_bounds[0] - orig_bounds[0]
                    actual_y_offset = final_bounds[1] - orig_bounds[1]

                    logger.debug(f"üìç –ù–û–í–û–ï –õ–£–ß–®–ï–ï –†–ê–ó–ú–ï–©–ï–ù–ò–ï –¥–ª—è {carpet.filename}:")
                    logger.debug(
                        f"   –£–≥–æ–ª: {angle}¬∞, –ü–æ–∑–∏—Ü–∏—è: ({best_x:.1f}, {best_y:.1f}), Score: {total_score:.0f}"
                    )
                    logger.debug(f"   –§–∏–Ω–∞–ª—å–Ω—ã–µ bounds: {final_bounds}")

                    best_placement = {
                        "polygon": translated,
                        "x_offset": actual_x_offset,
                        "y_offset": actual_y_offset,
                        "angle": angle,
                    }

        # Apply best placement if found
        if best_placement:
            new_carpet = PlacedCarpet(
                polygon=best_placement["polygon"],  # type: ignore
                carpet_id=carpet.carpet_id,
                priority=carpet.priority,
                x_offset=best_placement["x_offset"],  # type: ignore
                y_offset=best_placement["y_offset"],  # type: ignore
                angle=best_placement["angle"],  # type: ignore
                filename=carpet.filename,
                color=carpet.color,
                order_id=carpet.order_id,
            )
            placed.append(new_carpet)
            logger.debug(
                f"‚úÖ –†–∞–∑–º–µ—â—ë–Ω –∫–æ–≤—ë—Ä {carpet.filename} —Å —É–≥–ª–æ–º {best_placement['angle']}¬∞"
            )
            logger.debug(
                f"   Polygon bounds —Å—Ä–∞–∑—É –ø–æ—Å–ª–µ —Ä–∞–∑–º–µ—â–µ–Ω–∏—è: {new_carpet.polygon.bounds}"
            )

            # POST-PLACEMENT OPTIMIZATION - DISABLED
            # –≠—Ç–∞ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –ø–µ—Ä–µ—Ä–∞–∑–º–µ—â–∞–µ—Ç –∫–æ–≤—Ä—ã –∏ –ª–æ–º–∞–µ—Ç –ø—Ä–∞–≤–∏–ª—å–Ω—É—é —Ä–∞—Å–∫–ª–∞–¥–∫—É
            # –∏–∑ find_bottom_left_position —Å —É–ª—É—á—à–µ–Ω–Ω—ã–º scoring
            if False and len(placed) >= 2:  # –û–¢–ö–õ–Æ–ß–ï–ù–û
                try:
                    # –≠—Ç–∞–ø 1: –ê–ì–†–ï–°–°–ò–í–ù–ê–Ø Post-Placement –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è (–ø–æ–ª–Ω–æ–µ –ø–µ—Ä–µ—Ä–∞–∑–º–µ—â–µ–Ω–∏–µ –ø—Ä–æ–±–ª–µ–º–Ω—ã—Ö –∫–æ–≤—Ä–æ–≤)
                    # post_optimized = post_placement_optimize_aggressive(
                    #    placed, sheet_width_mm, sheet_height_mm
                    # )

                    # –≠—Ç–∞–ø 2: –ì—Ä–∞–≤–∏—Ç–∞—Ü–∏—è –¥–ª—è —Ñ–∏–Ω–∞–ª—å–Ω–æ–π –∫–æ–º–ø–∞–∫—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏
                    gravity_optimized = apply_tetris_gravity(
                        placed, sheet_width_mm, sheet_height_mm
                    )

                    # –≠—Ç–∞–ø 3: –ù–û–í–û–ï! –°–∂–∞—Ç–∏–µ –∫ –ø—Ä–∞–≤–æ–º—É –∫—Ä–∞—é (–∫–∞–∫ –≤ –Ω–∞—Å—Ç–æ—è—â–µ–º –¢–µ—Ç—Ä–∏—Å–µ)
                    right_compacted = apply_tetris_right_compaction(
                        gravity_optimized, sheet_width_mm, sheet_height_mm
                    )

                    # –≠—Ç–∞–ø 4: –§–∏–Ω–∞–ª—å–Ω–∞—è –≥—Ä–∞–≤–∏—Ç–∞—Ü–∏—è –ø–æ—Å–ª–µ —Å–∂–∞—Ç–∏—è –∫ –ø—Ä–∞–≤–æ–º—É –∫—Ä–∞—é
                    gravity_optimized2 = apply_tetris_gravity(
                        right_compacted, sheet_width_mm, sheet_height_mm
                    )

                    # –≠—Ç–∞–ø 5: –°–∂–∞—Ç–∏–µ –∫ –ª–µ–≤–æ–º—É –∫—Ä–∞—é –¥–ª—è –ø–ª–æ—Ç–Ω–æ–π —É–ø–∞–∫–æ–≤–∫–∏
                    final_optimized = apply_tetris_left_compaction(
                        gravity_optimized2, sheet_width_mm, sheet_height_mm
                    )

                    # –ö–†–ò–¢–ò–ß–ù–û: –ü—Ä–æ–≤–µ—Ä—è–µ–º –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å —Ñ–∏–Ω–∞–ª—å–Ω–æ–≥–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ —Å —É–ª—å—Ç—Ä–∞-—Å—Ç—Ä–æ–≥–∏–º –∫–æ–Ω—Ç—Ä–æ–ª–µ–º
                    collision_found = False
                    for i in range(len(final_optimized)):
                        for j in range(i + 1, len(final_optimized)):
                            if check_collision(
                                final_optimized[i].polygon,
                                final_optimized[j].polygon,
                                min_gap=10.0,  # –°—Ç—Ä–æ–≥–∏–π 2–º–º –∑–∞–∑–æ—Ä
                            ):
                                collision_found = True
                                break
                        if collision_found:
                            break

                    if not collision_found:
                        placed = final_optimized  # –ü—Ä–∏–º–µ–Ω—è–µ–º –ø–æ–ª–Ω—É—é –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—é

                except Exception:
                    logger.exception("‚ùå –û—à–∏–±–∫–∞ Post-Placement –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏.")

            placed_successfully = True
        else:
            # Fallback to original grid method if no bottom-left position found
            simple_bounds = carpet.polygon.bounds
            simple_width = simple_bounds[2] - simple_bounds[0]
            simple_height = simple_bounds[3] - simple_bounds[1]

            # Optimized grid placement as fallback with timeout
            max_grid_attempts = (
                5 if len(placed) > 10 else 10
            )  # Further reduced for many obstacles
            if sheet_width_mm > simple_width:
                x_positions = np.linspace(
                    0, sheet_width_mm - simple_width, max_grid_attempts
                )
            else:
                x_positions = [0]

            if sheet_height_mm > simple_height:
                y_positions = np.linspace(
                    0, sheet_height_mm - simple_height, max_grid_attempts
                )
            else:
                y_positions = [0]

            for grid_x in x_positions:
                for grid_y in y_positions:
                    x_offset = grid_x - simple_bounds[0]
                    y_offset = grid_y - simple_bounds[1]

                    # Fast bounds check with minimal tolerance for tight packing
                    test_bounds = (
                        simple_bounds[0] + x_offset,
                        simple_bounds[1] + y_offset,
                        simple_bounds[2] + x_offset,
                        simple_bounds[3] + y_offset,
                    )

                    if not (
                        test_bounds[0] >= -0.01
                        and test_bounds[1] >= -0.01
                        and test_bounds[2] <= sheet_width_mm + 0.01
                        and test_bounds[3] <= sheet_height_mm + 0.01
                    ):
                        continue

                    # Skip ALL bounding box checks - use only true geometric collision
                    translated = translate_polygon(carpet.polygon, x_offset, y_offset)

                    # Final precise collision check using STRtree
                    placed_polygons = [p.polygon for p in placed]
                    collision = check_collision_with_strtree(
                        translated, placed_polygons
                    )

                    if not collision:
                        placed.append(
                            PlacedCarpet(
                                polygon=translated,
                                carpet_id=carpet.carpet_id,
                                priority=carpet.priority,
                                x_offset=x_offset,
                                y_offset=y_offset,
                                angle=0,
                                filename=carpet.filename,
                                color=carpet.color,
                                order_id=carpet.order_id,
                            )
                        )
                        placed_successfully = True
                        break

                if placed_successfully:
                    break

        if not placed_successfully:
            unplaced.append(
                UnplacedCarpet(
                    polygon=carpet.polygon,
                    carpet_id=carpet.carpet_id,
                    priority=carpet.priority,
                    filename=carpet.filename,
                    color=carpet.color,
                    order_id=carpet.order_id,
                )
            )
    # –ö–†–ò–¢–ò–ß–ù–û: –î–æ–±–∞–≤–ª—è–µ–º –ø—Ä–æ–ø—É—â–µ–Ω–Ω—ã–µ –∫–æ–≤—Ä—ã –≤ unplaced —á—Ç–æ–±—ã –æ–Ω–∏ –Ω–µ —Ç–µ—Ä—è–ª–∏—Å—å
    if processed_count < total_carpet_count:
        for i, carpet in enumerate(sorted_polygons):
            if not should_process_carpet(i, total_carpet_count, len(placed)):
                # –≠—Ç–æ—Ç –∫–æ–≤–µ—Ä –±—ã–ª –ø—Ä–æ–ø—É—â–µ–Ω - –¥–æ–±–∞–≤–ª—è–µ–º –≤ unplaced
                unplaced.append(
                    UnplacedCarpet(
                        polygon=carpet.polygon,
                        carpet_id=carpet.carpet_id,
                        priority=carpet.priority,
                        filename=carpet.filename,
                        color=carpet.color,
                        order_id=carpet.order_id,
                    )
                )

    # PERFORMANCE: –õ–æ–≥–∏—Ä—É–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –æ–±—Ä–∞–±–æ—Ç–∫–∏
    if total_carpet_count > 100:
        skipped_count = total_carpet_count - processed_count
        logger.info(
            f"üìä –û–±—Ä–∞–±–æ—Ç–∞–Ω–æ {processed_count} –∏–∑ {total_carpet_count} –∫–æ–≤—Ä–æ–≤, –ø—Ä–æ–ø—É—â–µ–Ω–æ {skipped_count}, —Ä–∞–∑–º–µ—â–µ–Ω–æ {len(placed)}, –≤ unplaced {len(unplaced)}"
        )

    # ULTRA-AGGRESSIVE LEFT COMPACTION - always apply for maximum density
    # placed = simple_compaction(placed, sheet_size, min_gap=1.0)

    # # ULTRA-AGGRESSIVE LEFT COMPACTION - –û–¢–ö–õ–Æ–ß–ï–ù–ê –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–π
    if False and len(placed) <= 20:  # –û–¢–ö–õ–Æ–ß–ï–ù–û: –≤—ã–∑—ã–≤–∞–µ—Ç –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è
        # Ultra-aggressive left compaction to squeeze everything left - –¢–ï–°–¢–ò–†–£–ï–ú
        placed = ultra_left_compaction(placed, sheet_size, target_width_fraction=0.7)
        #
        # Simple compaction with aggressive left push - –¢–ï–°–¢–ò–†–£–ï–ú
        placed = simple_compaction(placed, sheet_size)
    #
    #     # Additional edge snapping for maximum left compaction - –¢–ï–°–¢–ò–†–£–ï–ú
    #     placed = fast_edge_snap(placed, sheet_size)
    #
    #     # Final ultra-left compaction - –¢–ï–°–¢–ò–†–£–ï–ú
    #     placed = ultra_left_compaction(placed, sheet_size, target_width_fraction=0.5)
    #
    #     # Light tightening to clean up - –¢–ï–°–¢–ò–†–£–ï–ú
    #     placed = tighten_layout(placed, sheet_size, min_gap=10.0, step=2.0, max_passes=1)
    elif (
        len(placed) <= 35
    ):  # COMPACTION DISABLED - breaks optimal layout from find_bottom_left_position
        # placed = ultra_left_compaction(placed, sheet_size, target_width_fraction=0.7)
        # placed = simple_compaction(placed, sheet_size)
        pass
    #     placed = fast_edge_snap(placed, sheet_size)
    #
    # # No optimization for very large sets

    # üéØ –§–ò–ù–ê–õ–¨–ù–ê–Ø –ö–û–ú–ë–ò–ù–ò–†–û–í–ê–ù–ù–ê–Ø –ö–û–ú–ü–†–ï–°–°–ò–Ø: –í–†–ï–ú–ï–ù–ù–û –û–¢–ö–õ–Æ–ß–ï–ù–ê
    # –û—Ç–∫–ª—é—á–∞–µ–º –∫–æ–º–ø—Ä–µ—Å—Å–∏—é –¥–ª—è –∏—Å–∫–ª—é—á–µ–Ω–∏—è –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–π
    logger.info(f"üìä –†–∞–∑–º–µ—â–µ–Ω–æ {len(placed)} –∫–æ–≤—Ä–æ–≤ –Ω–∞ –ª–∏—Å—Ç–µ")
    logger.warning("‚ö†Ô∏è –ö–û–ú–ü–†–ï–°–°–ò–Ø –û–¢–ö–õ–Æ–ß–ï–ù–ê –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–π")

    # üîç –§–ò–ù–ê–õ–¨–ù–ê–Ø –ü–†–û–í–ï–†–ö–ê –ù–ê –ü–ï–†–ï–°–ï–ß–ï–ù–ò–Ø
    if placed:
        logger.info("üîç –í—ã–ø–æ–ª–Ω—è–µ–º —Ñ–∏–Ω–∞–ª—å–Ω—É—é –ø—Ä–æ–≤–µ—Ä–∫—É –Ω–∞ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è...")
        collision_found = False
        for i in range(len(placed)):
            for j in range(i + 1, len(placed)):
                if check_collision(
                    placed[i].polygon,
                    placed[j].polygon,
                    min_gap=10.0,
                ):
                    collision_found = True
                    logger.error(
                        f"‚ùå –ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –û–®–ò–ë–ö–ê: –û–±–Ω–∞—Ä—É–∂–µ–Ω–æ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ –º–µ–∂–¥—É –∫–æ–≤—Ä–∞–º–∏ {i} –∏ {j}"
                    )
                    logger.error(f"   –ö–æ–≤—ë—Ä {i}: {placed[i].filename}")
                    logger.error(f"   –ö–æ–≤—ë—Ä {j}: {placed[j].filename}")
                    break
            if collision_found:
                break

        if not collision_found:
            logger.info("‚úì –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–æ–π–¥–µ–Ω–∞: –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–π –Ω–µ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–æ")
        else:
            logger.error("‚ùå –í–ù–ò–ú–ê–ù–ò–ï: –û–±–Ω–∞—Ä—É–∂–µ–Ω—ã –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è –≤ —Ñ–∏–Ω–∞–ª—å–Ω–æ–π —Ä–∞—Å–∫–ª–∞–¥–∫–µ!")

    # if placed and len(placed) <= 100:
    #     try:
    #         logger.info(f"üéØ –ü—Ä–∏–º–µ–Ω—è–µ–º –∫–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—É—é –∫–æ–º–ø—Ä–µ—Å—Å–∏—é –∫ {len(placed)} –∫–æ–≤—Ä–∞–º...")
    #         compacted_placed = apply_combined_compaction(
    #             placed, sheet_width_mm, sheet_height_mm, max_iterations=3
    #         )
    #
    #         # –ü—Ä–æ–≤–µ—Ä—è–µ–º –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
    #         collision_found = False
    #         for i in range(len(compacted_placed)):
    #             for j in range(i + 1, len(compacted_placed)):
    #                 if check_collision(
    #                     compacted_placed[i].polygon,
    #                     compacted_placed[j].polygon,
    #                     min_gap=10.0,
    #                 ):
    #                     collision_found = True
    #                     logger.warning(f"‚ö†Ô∏è –û–±–Ω–∞—Ä—É–∂–µ–Ω–∞ –∫–æ–ª–ª–∏–∑–∏—è –ø–æ—Å–ª–µ –∫–æ–º–ø—Ä–µ—Å—Å–∏–∏ –º–µ–∂–¥—É {i} –∏ {j}")
    #                     break
    #             if collision_found:
    #                 break
    #
    #         if not collision_found:
    #             placed = compacted_placed
    #             logger.info("‚úì –ö–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –∫–æ–º–ø—Ä–µ—Å—Å–∏—è –ø—Ä–∏–º–µ–Ω–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ")
    #         else:
    #             logger.warning("‚ö†Ô∏è –û—Ç–∫–∞—Ç—ã–≤–∞–µ–º –∫–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—É—é –∫–æ–º–ø—Ä–µ—Å—Å–∏—é –∏–∑-–∑–∞ –∫–æ–ª–ª–∏–∑–∏–π")
    #     except Exception as e:
    #         logger.exception(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–∏ –∫–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ–π –∫–æ–º–ø—Ä–µ—Å—Å–∏–∏: {e}")
    # else:
    #     if placed:
    #         logger.warning(f"‚ö†Ô∏è –ö–æ–º–ø—Ä–µ—Å—Å–∏—è –ù–ï –ø—Ä–∏–º–µ–Ω—è–µ—Ç—Å—è: —Å–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –∫–æ–≤—Ä–æ–≤ ({len(placed)} > 100)")

    # –û–¢–õ–ê–î–ö–ê: –ü—Ä–æ–≤–µ—Ä—è–µ–º bounds –ø–µ—Ä–µ–¥ –≤–æ–∑–≤—Ä–∞—Ç–æ–º
    logger.debug("üîç –§–ò–ù–ê–õ–¨–ù–´–ï BOUNDS –ü–ï–†–ï–î –í–û–ó–í–†–ê–¢–û–ú:")
    for i, carpet in enumerate(placed):
        logger.debug(f"   –ö–æ–≤—ë—Ä {i} ({carpet.filename}): {carpet.polygon.bounds}")

    return placed, unplaced


def apply_gravity_optimization(
    placed_carpets: list[PlacedCarpet], sheet_width_mm: float, sheet_height_mm: float
) -> list[PlacedCarpet]:
    """
    Improved gravity optimization for better sheet utilization while maintaining performance.
    """
    if not placed_carpets:
        return placed_carpets

    # STEP 1: Vertical compaction (move down)
    sorted_carpets = sorted(
        placed_carpets, key=lambda c: c.polygon.bounds[3], reverse=True
    )
    vertically_optimized = []

    for i, carpet in enumerate(sorted_carpets):
        other_carpets = vertically_optimized + sorted_carpets[i + 1 :]
        moved_carpet = move_carpet_down(
            carpet, other_carpets, sheet_width_mm, sheet_height_mm
        )
        vertically_optimized.append(moved_carpet)

    # STEP 2: Horizontal compaction (move left)
    sorted_by_x = sorted(
        vertically_optimized, key=lambda c: c.polygon.bounds[2], reverse=True
    )
    horizontally_optimized = []

    for i, carpet in enumerate(sorted_by_x):
        other_carpets = horizontally_optimized + sorted_by_x[i + 1 :]
        moved_carpet = move_carpet_left(
            carpet, other_carpets, sheet_width_mm, sheet_height_mm
        )
        horizontally_optimized.append(moved_carpet)

    return horizontally_optimized


def move_carpet_down(
    carpet: PlacedCarpet,
    other_carpets: list[PlacedCarpet],
    sheet_width_mm: float,
    sheet_height_mm: float,
) -> PlacedCarpet:
    """Move a single carpet as low as possible without collisions, including trying different rotations."""
    import shapely.affinity

    bounds = carpet.polygon.bounds
    poly_width = bounds[2] - bounds[0]
    poly_height = bounds[3] - bounds[1]

    best_position = (bounds[0], bounds[1], carpet.angle)  # Current position and angle
    max_improvement = 0  # Track how much we moved down

    # Try different Y positions from bottom to current position
    step_size = 10  # 1cm steps for better precision

    # Try different rotations to fit through narrow spaces
    angles_to_try = [carpet.angle]  # Start with current angle
    if carpet.angle == 0:
        angles_to_try.extend([90, 180, 270])
    elif carpet.angle == 90:
        angles_to_try.extend([0, 180, 270])
    elif carpet.angle == 180:
        angles_to_try.extend([0, 90, 270])
    elif carpet.angle == 270:
        angles_to_try.extend([0, 90, 180])

    # Start from bottom and go up, looking for the lowest possible position
    for test_y in range(
        0, int(sheet_height_mm - max(poly_width, poly_height)) + step_size, step_size
    ):
        # Only consider positions that are lower than current position (actual improvement)
        if test_y >= bounds[1]:
            continue

        # Try different rotations
        for test_angle in angles_to_try:
            # Create rotated polygon at origin
            rotated_polygon = shapely.affinity.rotate(
                carpet.polygon, test_angle - carpet.angle, origin=(0, 0)
            )
            rot_bounds = rotated_polygon.bounds
            rot_width = rot_bounds[2] - rot_bounds[0]
            rot_height = rot_bounds[3] - rot_bounds[1]

            # Also try X adjustments for better fitting
            x_offsets = [
                bounds[0],
                bounds[0] - 20,
                bounds[0] + 20,
                bounds[0] - 50,
                bounds[0] + 50,
            ]

            for test_x_base in x_offsets:
                # Skip if rotated carpet would be outside sheet bounds
                if test_x_base < 0 or test_x_base + rot_width > sheet_width_mm:
                    continue
                if test_y + rot_height > sheet_height_mm:
                    continue

                # Calculate final position by moving rotated polygon to test position
                # First move to origin, then rotate, then move to target position
                dx_to_origin = -bounds[0]
                dy_to_origin = -bounds[1]
                moved_to_origin = shapely.affinity.translate(
                    carpet.polygon, dx_to_origin, dy_to_origin
                )
                rotated_at_origin = shapely.affinity.rotate(
                    moved_to_origin, test_angle - carpet.angle, origin=(0, 0)
                )
                test_polygon = shapely.affinity.translate(
                    rotated_at_origin, test_x_base, test_y
                )

                test_bounds = test_polygon.bounds

                # Double-check bounds
                if (
                    test_bounds[0] < 0
                    or test_bounds[1] < 0
                    or test_bounds[2] > sheet_width_mm
                    or test_bounds[3] > sheet_height_mm
                ):
                    continue

                # Check for collisions with other carpets
                has_collision = False
                for other in other_carpets:
                    if test_polygon.intersects(other.polygon):
                        intersection = test_polygon.intersection(other.polygon)
                        if (
                            hasattr(intersection, "area") and intersection.area > 1
                        ):  # Reduced overlap tolerance for tighter packing
                            has_collision = True
                            break

                if not has_collision:
                    improvement = bounds[1] - test_y  # How much we moved down
                    if improvement > max_improvement:
                        max_improvement = improvement
                        best_position = (test_x_base, test_y, test_angle)

    # If we found a better position, create new carpet
    if max_improvement > 1:  # Move even for small improvements (>1mm)
        new_x, new_y, new_angle = best_position

        # Calculate the final polygon position
        dx_to_origin = -bounds[0]
        dy_to_origin = -bounds[1]
        moved_to_origin = shapely.affinity.translate(
            carpet.polygon, dx_to_origin, dy_to_origin
        )
        rotated_at_origin = shapely.affinity.rotate(
            moved_to_origin, new_angle - carpet.angle, origin=(0, 0)
        )
        new_polygon = shapely.affinity.translate(rotated_at_origin, new_x, new_y)

        # Calculate the offset change
        new_bounds = new_polygon.bounds
        dx_total = new_bounds[0] - bounds[0]
        dy_total = new_bounds[1] - bounds[1]

        return PlacedCarpet(
            polygon=new_polygon,
            carpet_id=carpet.carpet_id,
            priority=carpet.priority,
            x_offset=carpet.x_offset + dx_total,
            y_offset=carpet.y_offset + dy_total,
            angle=new_angle,
            filename=carpet.filename,
            color=carpet.color,
            order_id=carpet.order_id,
        )

    return carpet  # No significant improvement found


def move_carpet_left(
    carpet: PlacedCarpet,
    other_carpets: list[PlacedCarpet],
    sheet_width_mm: float,
    sheet_height_mm: float,
) -> PlacedCarpet:
    """Move a single carpet as far left as possible without collisions, including trying different rotations."""
    import shapely.affinity

    bounds = carpet.polygon.bounds

    best_position = (bounds[0], bounds[1], carpet.angle)  # Current position and angle
    max_improvement = 0  # Track how much we moved left

    # Try different X positions from left to current position
    step_size = 10  # 1cm steps for better precision

    # Try different rotations to fit through narrow spaces
    angles_to_try = [carpet.angle]  # Start with current angle
    if carpet.angle == 0:
        angles_to_try.extend([90, 180, 270])
    elif carpet.angle == 90:
        angles_to_try.extend([0, 180, 270])
    elif carpet.angle == 180:
        angles_to_try.extend([0, 90, 270])
    elif carpet.angle == 270:
        angles_to_try.extend([0, 90, 180])

    # Start from left edge and go right, looking for the leftmost possible position
    for test_x in range(0, int(bounds[0]) + step_size, step_size):
        # Only consider positions that are further left than current position (actual improvement)
        if test_x >= bounds[0]:
            continue

        # Try different rotations
        for test_angle in angles_to_try:
            # Create rotated polygon at origin
            rotated_polygon = shapely.affinity.rotate(
                carpet.polygon, test_angle - carpet.angle, origin=(0, 0)
            )
            rot_bounds = rotated_polygon.bounds
            rot_width = rot_bounds[2] - rot_bounds[0]
            rot_height = rot_bounds[3] - rot_bounds[1]

            # Also try Y adjustments for better fitting
            y_offsets = [
                bounds[1],
                bounds[1] - 20,
                bounds[1] + 20,
                bounds[1] - 50,
                bounds[1] + 50,
            ]

            for test_y_base in y_offsets:
                # Skip if rotated carpet would be outside sheet bounds
                if test_x + rot_width > sheet_width_mm:
                    continue
                if test_y_base < 0 or test_y_base + rot_height > sheet_height_mm:
                    continue

                # Calculate final position by moving rotated polygon to test position
                # First move to origin, then rotate, then move to target position
                dx_to_origin = -bounds[0]
                dy_to_origin = -bounds[1]
                moved_to_origin = shapely.affinity.translate(
                    carpet.polygon, dx_to_origin, dy_to_origin
                )
                rotated_at_origin = shapely.affinity.rotate(
                    moved_to_origin, test_angle - carpet.angle, origin=(0, 0)
                )
                test_polygon = shapely.affinity.translate(
                    rotated_at_origin, test_x, test_y_base
                )

                test_bounds = test_polygon.bounds

                # Double-check bounds
                if (
                    test_bounds[0] < 0
                    or test_bounds[1] < 0
                    or test_bounds[2] > sheet_width_mm
                    or test_bounds[3] > sheet_height_mm
                ):
                    continue

                # Check for collisions with other carpets
                has_collision = False
                for other in other_carpets:
                    if test_polygon.intersects(other.polygon):
                        intersection = test_polygon.intersection(other.polygon)
                        if (
                            hasattr(intersection, "area") and intersection.area > 1
                        ):  # Reduced overlap tolerance for tighter packing
                            has_collision = True
                            break

                if not has_collision:
                    improvement = bounds[0] - test_x  # How much we moved left
                    if improvement > max_improvement:
                        max_improvement = improvement
                        best_position = (test_x, test_y_base, test_angle)

    # If we found a better position, create new carpet
    if max_improvement > 1:  # Move even for small improvements (>1mm)
        new_x, new_y, new_angle = best_position

        # Calculate the final polygon position
        dx_to_origin = -bounds[0]
        dy_to_origin = -bounds[1]
        moved_to_origin = shapely.affinity.translate(
            carpet.polygon, dx_to_origin, dy_to_origin
        )
        rotated_at_origin = shapely.affinity.rotate(
            moved_to_origin, new_angle - carpet.angle, origin=(0, 0)
        )
        new_polygon = shapely.affinity.translate(rotated_at_origin, new_x, new_y)

        # Calculate the offset change
        new_bounds = new_polygon.bounds
        dx_total = new_bounds[0] - bounds[0]
        dy_total = new_bounds[1] - bounds[1]

        return PlacedCarpet(
            polygon=new_polygon,
            carpet_id=carpet.carpet_id,
            priority=carpet.priority,
            x_offset=carpet.x_offset + dx_total,
            y_offset=carpet.y_offset + dy_total,
            angle=new_angle,
            filename=carpet.filename,
            color=carpet.color,
            order_id=carpet.order_id,
        )

    return carpet  # No significant improvement found


def move_carpet_down_aggressive(
    carpet: PlacedCarpet,
    other_carpets: list[PlacedCarpet],
    sheet_width_mm: float,
    sheet_height_mm: float,
) -> PlacedCarpet:
    """AGGRESSIVE downward movement with fine-grained steps and rotation."""
    import shapely.affinity

    bounds = carpet.polygon.bounds
    best_position = (bounds[0], bounds[1], carpet.angle)
    max_improvement = 0

    step_size = 5  # 5mm steps for good balance of precision/speed

    # Try current angle and all 90-degree rotations
    for test_angle in [carpet.angle, 0, 90, 180, 270]:
        if test_angle == carpet.angle:
            rotated_polygon = carpet.polygon
        else:
            rotated_polygon = shapely.affinity.rotate(
                carpet.polygon, test_angle - carpet.angle, origin=(0, 0)
            )

        rot_bounds = rotated_polygon.bounds
        rot_width = rot_bounds[2] - rot_bounds[0]

        # Try moving from bottom up to current position
        for test_y in range(0, int(bounds[1]) + step_size, step_size):
            if test_y >= bounds[1]:
                continue

            # Try slight X adjustments for better fitting
            for x_adjust in [-50, -20, 0, 20, 50]:
                test_x = bounds[0] + x_adjust
                if test_x < 0 or test_x + rot_width > sheet_width_mm:
                    continue

                # Create test position
                dx_to_origin = -bounds[0]
                dy_to_origin = -bounds[1]
                moved_to_origin = shapely.affinity.translate(
                    carpet.polygon, dx_to_origin, dy_to_origin
                )
                rotated_at_origin = shapely.affinity.rotate(
                    moved_to_origin, test_angle - carpet.angle, origin=(0, 0)
                )
                test_polygon = shapely.affinity.translate(
                    rotated_at_origin, test_x, test_y
                )

                test_bounds = test_polygon.bounds
                if (
                    test_bounds[0] < 0
                    or test_bounds[1] < 0
                    or test_bounds[2] > sheet_width_mm
                    or test_bounds[3] > sheet_height_mm
                ):
                    continue

                # Check collisions with minimal gap tolerance
                has_collision = False
                for other in other_carpets:
                    if test_polygon.intersects(other.polygon):
                        intersection = test_polygon.intersection(other.polygon)
                        if (
                            hasattr(intersection, "area") and intersection.area > 0.1
                        ):  # Ultra-tight packing
                            has_collision = True
                            break

                if not has_collision:
                    improvement = bounds[1] - test_y
                    if improvement > max_improvement:
                        max_improvement = improvement
                        best_position = (test_x, test_y, test_angle)

    # Apply best position if found
    if max_improvement > 0.1:  # Any improvement is valuable
        new_x, new_y, new_angle = best_position

        dx_to_origin = -bounds[0]
        dy_to_origin = -bounds[1]
        moved_to_origin = shapely.affinity.translate(
            carpet.polygon, dx_to_origin, dy_to_origin
        )
        rotated_at_origin = shapely.affinity.rotate(
            moved_to_origin, new_angle - carpet.angle, origin=(0, 0)
        )
        new_polygon = shapely.affinity.translate(rotated_at_origin, new_x, new_y)

        new_bounds = new_polygon.bounds
        dx_total = new_bounds[0] - bounds[0]
        dy_total = new_bounds[1] - bounds[1]

        return PlacedCarpet(
            polygon=new_polygon,
            carpet_id=carpet.carpet_id,
            priority=carpet.priority,
            x_offset=carpet.x_offset + dx_total,
            y_offset=carpet.y_offset + dy_total,
            angle=new_angle,
            filename=carpet.filename,
            color=carpet.color,
            order_id=carpet.order_id,
        )

    return carpet


def move_carpet_left_aggressive(
    carpet: PlacedCarpet,
    other_carpets: list[PlacedCarpet],
    sheet_width_mm: float,
    sheet_height_mm: float,
) -> PlacedCarpet:
    """AGGRESSIVE leftward movement with rotation support."""
    import shapely.affinity

    bounds = carpet.polygon.bounds
    best_position = (bounds[0], bounds[1], carpet.angle)
    max_improvement = 0

    step_size = 2  # 2mm steps for maximum precision

    # Try current angle and rotations
    for test_angle in [carpet.angle, 0, 90, 180, 270]:
        if test_angle == carpet.angle:
            rotated_polygon = carpet.polygon
        else:
            rotated_polygon = shapely.affinity.rotate(
                carpet.polygon, test_angle - carpet.angle, origin=(0, 0)
            )

        rot_bounds = rotated_polygon.bounds
        rot_width = rot_bounds[2] - rot_bounds[0]

        # Try moving from left edge to current position
        for test_x in range(0, int(bounds[0]) + step_size, step_size):
            if test_x >= bounds[0]:
                continue

            # Try Y adjustments
            for y_adjust in [-50, -20, 0, 20, 50]:
                test_y = bounds[1] + y_adjust
                if test_x + rot_width > sheet_width_mm:
                    continue

                # Create test position
                dx_to_origin = -bounds[0]
                dy_to_origin = -bounds[1]
                moved_to_origin = shapely.affinity.translate(
                    carpet.polygon, dx_to_origin, dy_to_origin
                )
                rotated_at_origin = shapely.affinity.rotate(
                    moved_to_origin, test_angle - carpet.angle, origin=(0, 0)
                )
                test_polygon = shapely.affinity.translate(
                    rotated_at_origin, test_x, test_y
                )

                test_bounds = test_polygon.bounds
                if (
                    test_bounds[0] < 0
                    or test_bounds[1] < 0
                    or test_bounds[2] > sheet_width_mm
                    or test_bounds[3] > sheet_height_mm
                ):
                    continue

                # Check collisions
                has_collision = False
                for other in other_carpets:
                    if test_polygon.intersects(other.polygon):
                        intersection = test_polygon.intersection(other.polygon)
                        if hasattr(intersection, "area") and intersection.area > 0.1:
                            has_collision = True
                            break

                if not has_collision:
                    improvement = bounds[0] - test_x
                    if improvement > max_improvement:
                        max_improvement = improvement
                        best_position = (test_x, test_y, test_angle)

    # Apply best position if found
    if max_improvement > 0.1:
        new_x, new_y, new_angle = best_position

        dx_to_origin = -bounds[0]
        dy_to_origin = -bounds[1]
        moved_to_origin = shapely.affinity.translate(
            carpet.polygon, dx_to_origin, dy_to_origin
        )
        rotated_at_origin = shapely.affinity.rotate(
            moved_to_origin, new_angle - carpet.angle, origin=(0, 0)
        )
        new_polygon = shapely.affinity.translate(rotated_at_origin, new_x, new_y)

        new_bounds = new_polygon.bounds
        dx_total = new_bounds[0] - bounds[0]
        dy_total = new_bounds[1] - bounds[1]

        return PlacedCarpet(
            polygon=new_polygon,
            x_offset=carpet.x_offset + dx_total,
            y_offset=carpet.y_offset + dy_total,
            angle=new_angle,
            filename=carpet.filename,
            color=carpet.color,
            order_id=carpet.order_id,
            carpet_id=carpet.carpet_id,
            priority=carpet.priority,
        )

    return carpet


def move_carpet_right_to_edge(
    carpet: PlacedCarpet,
    other_carpets: list[PlacedCarpet],
    sheet_width_mm: float,
    sheet_height_mm: float,
) -> PlacedCarpet:
    """Move carpet as far right as possible to maximize left space."""
    import shapely.affinity

    bounds = carpet.polygon.bounds
    poly_width = bounds[2] - bounds[0]

    best_x = bounds[0]
    max_improvement = 0

    # Try moving right from current position to edge
    step_size = 2
    for test_x in range(
        int(bounds[0]), int(sheet_width_mm - poly_width) + step_size, step_size
    ):
        if test_x <= bounds[0]:
            continue

        # Try slight Y adjustments
        for y_adjust in [-20, 0, 20]:
            test_y = bounds[1] + y_adjust

            dx = test_x - bounds[0]
            dy = test_y - bounds[1]
            test_polygon = shapely.affinity.translate(carpet.polygon, dx, dy)

            test_bounds = test_polygon.bounds
            if (
                test_bounds[0] < 0
                or test_bounds[1] < 0
                or test_bounds[2] > sheet_width_mm
                or test_bounds[3] > sheet_height_mm
            ):
                continue

            # Check collisions
            has_collision = False
            for other in other_carpets:
                if test_polygon.intersects(other.polygon):
                    intersection = test_polygon.intersection(other.polygon)
                    if hasattr(intersection, "area") and intersection.area > 0.1:
                        has_collision = True
                        break

            if not has_collision:
                improvement = test_x - bounds[0]
                if improvement > max_improvement:
                    max_improvement = improvement
                    best_x = test_x

    # Apply best position if found
    if max_improvement > 0.1:
        dx = best_x - bounds[0]
        new_polygon = shapely.affinity.translate(carpet.polygon, dx, 0)

        return PlacedCarpet(
            polygon=new_polygon,
            x_offset=carpet.x_offset + dx,
            y_offset=carpet.y_offset,
            angle=carpet.angle,
            filename=carpet.filename,
            color=carpet.color,
            order_id=carpet.order_id,
            carpet_id=carpet.carpet_id,
            priority=carpet.priority,
        )

    return carpet


def find_contour_following_position(
    polygon: Polygon, obstacles: list[Polygon], sheet_width: float, sheet_height: float
) -> tuple[float | None, float | None]:
    """Find position using TRUE CONTOUR-FOLLOWING - shapes can nestle into concave areas!"""
    bounds = polygon.bounds
    poly_width = bounds[2] - bounds[0]
    poly_height = bounds[3] - bounds[1]

    candidates = []

    # REVOLUTIONARY: Follow actual shape contours, not bounding boxes
    for obstacle in obstacles[:8]:  # Limit for performance
        # Get the actual boundary coordinates of the obstacle
        if hasattr(obstacle.exterior, "coords"):
            contour_points = list(obstacle.exterior.coords)

            # Generate positions along the actual contour with minimal gaps
            for i, (cx, cy) in enumerate(
                contour_points[:-1]
            ):  # Skip last duplicate point
                # Try positioning our polygon at various points along this contour
                test_positions = [
                    # Right of this contour point
                    (cx + 0.1, cy - poly_height / 2),
                    (cx + 0.1, cy),
                    (cx + 0.1, cy - poly_height),
                    # Above this contour point
                    (cx - poly_width / 2, cy + 0.1),
                    (cx, cy + 0.1),
                    (cx - poly_width, cy + 0.1),
                ]

                for test_x, test_y in test_positions:
                    if (
                        0 <= test_x <= sheet_width - poly_width
                        and 0 <= test_y <= sheet_height - poly_height
                    ):
                        candidates.append((test_x, test_y))

    # Add sheet edges with adaptive step for small polygons
    polygon_size = poly_width * poly_height
    is_small = polygon_size < 10000  # 100mm x 100mm

    step = 0.5 if is_small else max(1.0, min(poly_width, poly_height) / 10)

    for x in np.arange(0, sheet_width - poly_width + 1, step):
        candidates.append((x, 0))
    for y in np.arange(0, sheet_height - poly_height + 1, step):
        candidates.append((0, y))

    # Sort by bottom-left preference and limit candidates
    candidates = list(set(candidates))  # Remove duplicates
    candidates.sort(key=lambda pos: (pos[1], pos[0]))

    # Increase limit for small polygons to improve placement success
    max_candidates = 1000 if is_small else 600  # Reduced for speed
    candidates = candidates[: min(max_candidates, len(candidates))]

    # Test each position using true geometric collision detection
    for x, y in candidates:
        x_offset = x - bounds[0]
        y_offset = y - bounds[1]
        test_polygon = translate_polygon(polygon, x_offset, y_offset)

        # CRITICAL FIX: Check sheet boundaries first
        test_bounds = test_polygon.bounds
        if (
            test_bounds[0] < -0.1
            or test_bounds[1] < -0.1
            or test_bounds[2] > sheet_width + 0.1
            or test_bounds[3] > sheet_height + 0.1
        ):
            continue

        # Use STRtree for ultra-fast collision check
        collision = check_collision_with_strtree(test_polygon, obstacles)

        if not collision:
            return x, y

    return None, None


def calculate_tetris_quality_bonus(
    rotated_polygon: Polygon, all_placed: list, sheet_width: float, sheet_height: float
) -> float:
    """
    Calculate tetris quality bonus for a given orientation.

    Returns a bonus score (higher = better tetris quality) based on:
    1. Fill ratio (how well the shape fills its bounding box)
    2. Accessibility (how much space below is accessible for future carpets)
    3. Top space utilization (how much vertical space remains)
    """
    bounds = rotated_polygon.bounds

    # 1. Bounding box fill ratio
    bbox_area = (bounds[2] - bounds[0]) * (bounds[3] - bounds[1])
    actual_area = rotated_polygon.area
    fill_ratio = actual_area / bbox_area if bbox_area > 0 else 0

    # 2. Accessibility analysis - check space below for future placement
    test_points_below = []
    for x in np.linspace(bounds[0], bounds[2], 8):
        for y in np.linspace(max(0, bounds[1] - 100), bounds[1], 5):  # 100mm below
            test_points_below.append((x, y))

    if test_points_below:
        # Count accessible points (not inside any placed carpet)
        accessible_count = 0
        for point in test_points_below:
            accessible = True
            for placed_carpet in all_placed:
                if hasattr(placed_carpet, "polygon") and placed_carpet.polygon.contains(
                    Point(point)
                ):
                    accessible = False
                    break
            if accessible:
                accessible_count += 1

        accessibility_ratio = accessible_count / len(test_points_below)
    else:
        accessibility_ratio = 1.0

    # 3. Vertical space efficiency
    carpet_height = bounds[3] - bounds[1]
    remaining_height = sheet_height - carpet_height
    height_efficiency = remaining_height / sheet_height if sheet_height > 0 else 0

    # 4. Check if carpet creates "overhangs" that could trap space
    # Simple heuristic: if carpet is much wider than tall, it might create better base
    aspect_ratio = (bounds[2] - bounds[0]) / carpet_height if carpet_height > 0 else 1
    base_quality = min(aspect_ratio / 2.0, 1.0)  # Cap at 1.0

    # 5. Bottom placement preference (being close to bottom edge of sheet)
    bottom_distance = bounds[1]
    bottom_bonus = max(0, (100 - bottom_distance) / 100) if bottom_distance < 100 else 0

    # 6. –ù–û–í–û–ï: –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —Å–æ–∑–¥–∞–Ω–∏–µ "–∫–∞—Ä–º–∞–Ω–æ–≤" —Å–ø—Ä–∞–≤–∞ (–∑–∞–ø–µ—Ä—Ç–æ–≥–æ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–∞)
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ —Å–ø—Ä–∞–≤–∞ –æ—Ç –∫–æ–≤—Ä–∞ - –¥–æ—Å—Ç—É–ø–Ω–æ –ª–∏ –æ–Ω–æ —Å–≤–µ—Ä—Ö—É?
    pocket_penalty = 0
    right_edge = bounds[2]
    if right_edge < sheet_width - 50:  # –ï—Å—Ç—å –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ —Å–ø—Ä–∞–≤–∞ (>50–º–º)
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–æ—á–∫–∏ —Å–ø—Ä–∞–≤–∞ –Ω–∞ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å —Å–≤–µ—Ä—Ö—É
        test_points_right = []
        for x in np.linspace(
            right_edge + 10, min(right_edge + 200, sheet_width - 10), 5
        ):
            for y in np.linspace(bounds[1], bounds[3], 3):
                test_points_right.append((x, y))

        if test_points_right:
            blocked_from_top = 0
            for point in test_points_right:
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –∫–æ–≤—ë—Ä –≤—ã—à–µ —ç—Ç–æ–π —Ç–æ—á–∫–∏, –∫–æ—Ç–æ—Ä—ã–π –±–ª–æ–∫–∏—Ä—É–µ—Ç –¥–æ—Å—Ç—É–ø
                blocked = False
                for placed_carpet in all_placed:
                    if hasattr(placed_carpet, "polygon"):
                        pb = placed_carpet.polygon.bounds
                        # –ï—Å–ª–∏ –∫–æ–≤—ë—Ä –≤—ã—à–µ –∏ –ø–µ—Ä–µ–∫—Ä—ã–≤–∞–µ—Ç –ø–æ X
                        if pb[3] > point[1] and pb[0] <= point[0] <= pb[2]:
                            blocked = True
                            break
                if blocked:
                    blocked_from_top += 1

            pocket_ratio = (
                blocked_from_top / len(test_points_right) if test_points_right else 0
            )
            pocket_penalty = pocket_ratio  # 0..1, —á–µ–º –±–æ–ª—å—à–µ —Ç–µ–º —Ö—É–∂–µ

    # Weighted combination - —É–≤–µ–ª–∏—á–µ–Ω –≤–µ—Å —à—Ç—Ä–∞—Ñ–∞ –∑–∞ –∫–∞—Ä–º–∞–Ω—ã
    tetris_score = (
        fill_ratio * 0.25
        + accessibility_ratio * 0.35  # Most important - future space
        + height_efficiency * 0.2
        + base_quality * 0.1
        + bottom_bonus * 0.1
        - pocket_penalty * 0.5  # –£—Å–∏–ª–µ–Ω —à—Ç—Ä–∞—Ñ –∑–∞ —Å–æ–∑–¥–∞–Ω–∏–µ –∫–∞—Ä–º–∞–Ω–æ–≤
    )

    # Convert to bonus (scale to meaningful range for shape_bonus)
    bonus = int(tetris_score * 8000)  # –£–º–µ–Ω—å—à–µ–Ω –¥–ª—è –ª—É—á—à–µ–≥–æ –±–∞–ª–∞–Ω—Å–∞ —Å –¥—Ä—É–≥–∏–º–∏ —Ñ–∞–∫—Ç–æ—Ä–∞–º–∏

    return bonus


def find_super_dense_position(
    polygon: Polygon, obstacles: list[Polygon], sheet_width: float, sheet_height: float
) -> tuple[float | None, float | None]:
    """REVOLUTIONARY: Maximum density placement using exhaustive multi-strategy search."""
    bounds = polygon.bounds
    poly_width = bounds[2] - bounds[0]
    poly_height = bounds[3] - bounds[1]

    # Strategy 1: SMART grid search - adaptive step based on polygon size and existing density
    polygon_area = poly_width * poly_height

    # Adaptive step: smaller for small polygons, larger for big ones
    if polygon_area < 5000:  # Small carpet
        step = 1.0  # –£–≤–µ–ª–∏—á–∏–ª–∏ —Å 0.5 –¥–ª—è —É—Å–∫–æ—Ä–µ–Ω–∏—è
    elif polygon_area < 20000:  # Medium carpet
        step = 1.0
    else:  # Large carpet
        step = 2.0

    # Limit search area based on existing obstacles to avoid empty regions
    occupied_regions = []
    if obstacles:
        for obs in obstacles:
            obs_bounds = obs.bounds
            occupied_regions.append(obs_bounds)

    # Search in expanding rings from bottom-left
    max_candidates = 600  # Balanced for speed and quality
    all_candidates = []  # (x, y, x_offset, y_offset)

    for ring in range(20):  # Maximum 20 rings
        ring_step = step * (1 + ring * 0.5)  # Coarser at distance

        # Bottom edge of ring
        for x in np.arange(
            0, min(sheet_width - poly_width, ring * 50) + ring_step, ring_step
        ):
            y = ring * 10
            if y > sheet_height - poly_height:
                break

            x_offset = x - bounds[0]
            y_offset = y - bounds[1]

            # Quick bounds check
            test_bounds = (
                bounds[0] + x_offset,
                bounds[1] + y_offset,
                bounds[2] + x_offset,
                bounds[3] + y_offset,
            )
            if (
                test_bounds[0] >= -0.01
                and test_bounds[1] >= -0.01
                and test_bounds[2] <= sheet_width + 0.01
                and test_bounds[3] <= sheet_height + 0.01
            ):
                all_candidates.append((x, y, x_offset, y_offset))

            if len(all_candidates) > max_candidates:
                break

        if len(all_candidates) > max_candidates:
            break

    if not all_candidates:
        return None, None

    # CRITICAL: Sort by bottom-left preference (Y first, then X) for proper gravity
    all_candidates.sort(key=lambda c: (c[1], c[0]))

    # BATCH: Create all translated polygons at once
    test_polygons = [
        translate_polygon(polygon, x_off, y_off)
        for _x, _y, x_off, y_off in all_candidates
    ]

    # OPTIMIZATION: Update STRtree cache ONCE
    global _global_spatial_cache
    _global_spatial_cache.update(obstacles)

    # BATCH: Check all collisions at once using fast batch check
    collisions = batch_check_collisions_cached_fast(
        test_polygons, _global_spatial_cache, min_gap=10.0
    )

    # Find first non-colliding position (already sorted by Y, then X)
    for i, has_collision in enumerate(collisions):
        if not has_collision:
            x, y, _x_off, _y_off = all_candidates[i]
            return x, y

    return None, None


def find_enhanced_contour_following_position(
    polygon: Polygon, obstacles: list[Polygon], sheet_width: float, sheet_height: float
) -> tuple[float | None, float | None]:
    """Enhanced contour following - ALL obstacles, more positions."""
    bounds = polygon.bounds
    poly_width = bounds[2] - bounds[0]
    poly_height = bounds[3] - bounds[1]

    candidates = []

    # Strategy 1: Follow obstacle contours (limit for performance)
    for obstacle in obstacles[: min(len(obstacles), 5)]:  # Reduced for speed
        if hasattr(obstacle.exterior, "coords"):
            contour_points = list(obstacle.exterior.coords)

            # Sample contour points with stride for speed
            for i, (cx, cy) in enumerate(
                contour_points[:-1:5]
            ):  # Every 5th point for speed
                # More test positions around each contour point
                test_positions = [
                    # Right side positions (multiple heights)
                    (cx + 0.05, cy - poly_height + 0.05),
                    (cx + 0.05, cy - poly_height / 2),
                    (cx + 0.05, cy),
                    (cx + 0.05, cy + 0.05),
                    # Left side positions
                    (cx - poly_width - 0.05, cy - poly_height + 0.05),
                    (cx - poly_width - 0.05, cy - poly_height / 2),
                    (cx - poly_width - 0.05, cy),
                    (cx - poly_width - 0.05, cy + 0.05),
                    # Above positions (multiple widths)
                    (cx - poly_width + 0.05, cy + 0.05),
                    (cx - poly_width / 2, cy + 0.05),
                    (cx, cy + 0.05),
                    (cx + 0.05, cy + 0.05),
                    # Below positions
                    (cx - poly_width + 0.05, cy - poly_height - 0.05),
                    (cx - poly_width / 2, cy - poly_height - 0.05),
                    (cx, cy - poly_height - 0.05),
                    (cx + 0.05, cy - poly_height - 0.05),
                ]

                for test_x, test_y in test_positions:
                    if (
                        0 <= test_x <= sheet_width - poly_width
                        and 0 <= test_y <= sheet_height - poly_height
                    ):
                        candidates.append((test_x, test_y))

    # Strategy 2: Sheet edges with coarser step for speed
    edge_step = 1.0  # Increased from 0.05 for much better speed
    for x in np.arange(0, sheet_width - poly_width + edge_step, edge_step):
        candidates.append((x, 0))  # Bottom edge
        if sheet_height - poly_height > 0:
            candidates.append((x, sheet_height - poly_height))  # Top edge

    for y in np.arange(0, sheet_height - poly_height + edge_step, edge_step):
        candidates.append((0, y))  # Left edge
        if sheet_width - poly_width > 0:
            candidates.append((sheet_width - poly_width, y))  # Right edge

    # Remove duplicates and sort by preference (bottom-left first)
    candidates = list(set(candidates))
    candidates.sort(key=lambda pos: (pos[1], pos[0]))

    # BATCH OPTIMIZATION: Collect all valid candidates with offsets
    all_candidates = []  # (x, y, x_offset, y_offset)

    for x, y in candidates[:600]:  # Balanced for speed and quality
        x_offset = x - bounds[0]
        y_offset = y - bounds[1]

        # Bounds check
        test_bounds = (
            bounds[0] + x_offset,
            bounds[1] + y_offset,
            bounds[2] + x_offset,
            bounds[3] + y_offset,
        )
        if (
            test_bounds[0] < -0.01
            or test_bounds[1] < -0.01
            or test_bounds[2] > sheet_width + 0.01
            or test_bounds[3] > sheet_height + 0.01
        ):
            continue

        all_candidates.append((x, y, x_offset, y_offset))

    if not all_candidates:
        return None, None

    # CRITICAL: Sort by bottom-left preference (Y first, then X) for proper gravity
    all_candidates.sort(key=lambda c: (c[1], c[0]))

    # BATCH: Create all translated polygons at once
    test_polygons = [
        translate_polygon(polygon, x_off, y_off)
        for _x, _y, x_off, y_off in all_candidates
    ]

    # OPTIMIZATION: Update STRtree cache ONCE
    global _global_spatial_cache
    _global_spatial_cache.update(obstacles)

    # BATCH: Check all collisions at once using fast batch check with 1mm gap
    # Create buffered obstacles for min_gap check
    buffered_obstacles = [obs.buffer(1.0) for obs in obstacles] if obstacles else []

    # Update STRtree with buffered obstacles
    _global_spatial_cache.update(buffered_obstacles)

    # BATCH: Check all collisions at once
    collisions = batch_check_collisions_cached_fast(
        test_polygons, _global_spatial_cache
    )

    # Find first non-colliding position
    for i, has_collision in enumerate(collisions):
        if not has_collision:
            x, y, _x_off, _y_off = all_candidates[i]
            return x, y

    return None, None


def find_ultra_tight_position(
    polygon: Polygon, obstacles: list[Polygon], sheet_width: float, sheet_height: float
) -> tuple[float | None, float | None]:
    """Find ultra-tight position using ENHANCED maximum density algorithm."""

    # Try new SUPER DENSE algorithm first
    result = find_super_dense_position(polygon, obstacles, sheet_width, sheet_height)
    if result[0] is not None:
        return result

    # Try enhanced contour-following algorithm
    result = find_enhanced_contour_following_position(
        polygon, obstacles, sheet_width, sheet_height
    )
    if result[0] is not None:
        return result

    # Fallback to grid-based approach
    bounds = polygon.bounds
    poly_width = bounds[2] - bounds[0]
    poly_height = bounds[3] - bounds[1]

    # Use adaptive grid size - finer for smaller polygons
    polygon_size = poly_width * poly_height
    small_polygon = polygon_size < 10000  # 100mm x 100mm

    if small_polygon:
        step_size = 1.0  # Increased from 0.5 for speed
    elif len(obstacles) <= 5:
        step_size = 2.0  # Increased from 1.0 for speed
    else:
        step_size = 3.0  # Increased from 2.0 for speed

    candidates = []

    # Grid search with adaptive limits (reduced for performance)
    max_candidates = 350 if small_polygon else 200  # Balanced for speed and quality

    for x in np.arange(0, sheet_width - poly_width + 1, step_size):
        for y in np.arange(0, sheet_height - poly_height + 1, step_size):
            candidates.append((x, y))
            if len(candidates) >= max_candidates:
                break
        if len(candidates) >= max_candidates:
            break

    # BATCH OPTIMIZATION: Collect all valid candidates with offsets
    all_candidates = []  # (x, y, x_offset, y_offset)

    for x, y in candidates:
        x_offset = x - bounds[0]
        y_offset = y - bounds[1]

        # CRITICAL FIX: Check sheet boundaries first
        test_bounds = (
            bounds[0] + x_offset,
            bounds[1] + y_offset,
            bounds[2] + x_offset,
            bounds[3] + y_offset,
        )
        if (
            test_bounds[0] < -0.1
            or test_bounds[1] < -0.1
            or test_bounds[2] > sheet_width + 0.1
            or test_bounds[3] > sheet_height + 0.1
        ):
            continue

        all_candidates.append((x, y, x_offset, y_offset))

    if not all_candidates:
        return None, None

    # CRITICAL: Sort by bottom-left preference (Y first, then X) for proper gravity
    all_candidates.sort(key=lambda c: (c[1], c[0]))

    # BATCH: Create all translated polygons at once
    test_polygons = [
        translate_polygon(polygon, x_off, y_off)
        for _x, _y, x_off, y_off in all_candidates
    ]

    # OPTIMIZATION: Update STRtree cache ONCE
    global _global_spatial_cache
    _global_spatial_cache.update(obstacles)

    # BATCH: Check all collisions at once using fast batch check
    collisions = batch_check_collisions_cached_fast(
        test_polygons, _global_spatial_cache, min_gap=10.0
    )

    # Find first non-colliding position (already sorted by Y, then X)
    for i, has_collision in enumerate(collisions):
        if not has_collision:
            x, y, _x_off, _y_off = all_candidates[i]
            return x, y

    return None, None


class _Stats:
    call_counter = 0


def find_bottom_left_position_with_obstacles(
    polygon: Polygon, obstacles: list[Polygon], sheet_width: float, sheet_height: float
) -> tuple[float | None, float | None]:
    """Find the bottom-left position using FAST batch algorithm with tight packing."""
    # Try ultra-tight algorithm first
    result = find_ultra_tight_position(polygon, obstacles, sheet_width, sheet_height)
    if result[0] is not None:
        return result

    # Fallback to improved algorithm
    bounds = polygon.bounds
    poly_width = bounds[2] - bounds[0]
    poly_height = bounds[3] - bounds[1]

    # Generate candidate positions - ORIGINAL algorithm logic
    candidate_positions = []

    # ADAPTIVE STEP: Fine grid for small polygons, coarse for large ones
    polygon_size = poly_width * poly_height
    is_small = polygon_size < 10000  # 100mm x 100mm
    grid_step = 2.0 if is_small else 15  # Fine step for small polygons

    # Bottom edge positions
    for x in np.arange(0, sheet_width - poly_width + 1, grid_step):
        candidate_positions.append((x, 0))

    # Left edge positions
    for y in np.arange(0, sheet_height - poly_height + 1, grid_step):
        candidate_positions.append((0, y))

    # Positions based on existing obstacles (bottom-left principle)
    for obstacle in obstacles:
        obstacle_bounds = obstacle.bounds

        # Try position to the right of existing obstacle
        x = obstacle_bounds[2] + 3  # 3mm gap for safety
        if x + poly_width <= sheet_width:
            candidate_positions.append((x, obstacle_bounds[1]))  # Same Y as existing
            candidate_positions.append((x, 0))  # Bottom edge

        # Try position above existing obstacle
        y = obstacle_bounds[3] + 3  # 3mm gap for safety
        if y + poly_height <= sheet_height:
            candidate_positions.append((obstacle_bounds[0], y))  # Same X as existing
            candidate_positions.append((0, y))  # Left edge

    # Remove duplicates and sort by bottom-left preference (Y first, then X)
    candidate_positions = list(set(candidate_positions))
    candidate_positions.sort(key=lambda pos: (pos[1], pos[0]))

    if not candidate_positions:
        return None, None

    # BATCH OPTIMIZATION: Collect all valid candidates with offsets
    all_candidates = []  # (x, y, x_offset, y_offset)

    for x, y in candidate_positions:
        # Fast boundary pre-check
        if x + poly_width > sheet_width + 0.1 or y + poly_height > sheet_height + 0.1:
            continue
        if x < -0.1 or y < -0.1:
            continue

        # Pre-calculate translation offset
        x_offset = x - bounds[0]
        y_offset = y - bounds[1]

        # Check if bounds would be valid after translation
        test_bounds = (
            bounds[0] + x_offset,
            bounds[1] + y_offset,
            bounds[2] + x_offset,
            bounds[3] + y_offset,
        )
        if (
            test_bounds[0] < -0.1
            or test_bounds[1] < -0.1
            or test_bounds[2] > sheet_width + 0.1
            or test_bounds[3] > sheet_height + 0.1
        ):
            continue

        all_candidates.append((x, y, x_offset, y_offset))

    if not all_candidates:
        return None, None

    # BATCH: Create all translated polygons at once
    test_polygons = [
        translate_polygon(polygon, x_off, y_off)
        for _x, _y, x_off, y_off in all_candidates
    ]

    # OPTIMIZATION: Update STRtree cache ONCE
    global _global_spatial_cache
    _global_spatial_cache.update(obstacles)

    # BATCH: Check all collisions at once using fast batch check
    collisions = batch_check_collisions_cached_fast(
        test_polygons, _global_spatial_cache, min_gap=10.0
    )

    # Find first non-colliding position (already sorted by Y, then X for bottom-left)
    for i, has_collision in enumerate(collisions):
        if not has_collision:
            x, y, _x_off, _y_off = all_candidates[i]
            return x, y

    return None, None


def find_quick_position(
    polygon: Polygon, placed_polygons, sheet_width: float, sheet_height: float
) -> tuple[float | None, float | None]:
    """Quick position finding for scenarios with many obstacles."""
    bounds = polygon.bounds
    poly_width = bounds[2] - bounds[0]
    poly_height = bounds[3] - bounds[1]

    # Use reasonable steps for balance of speed and density
    step_size = 2.0  # Reduced from 5.0 for better placement options
    max_positions = 200  # Increased from 100 for better coverage

    # Generate minimal candidate set
    candidates = []

    # Bottom edge with large steps
    for x in np.arange(0, sheet_width - poly_width + 1, step_size):
        candidates.append((x, 0))
        if len(candidates) >= max_positions:
            break

    # Left edge with large steps
    for y in np.arange(0, sheet_height - poly_height + 1, step_size):
        candidates.append((0, y))
        if len(candidates) >= max_positions:
            break

    # Test positions quickly
    for x, y in candidates:
        if x + poly_width <= sheet_width and y + poly_height <= sheet_height:
            x_offset = x - bounds[0]
            y_offset = y - bounds[1]
            test_polygon = translate_polygon(polygon, x_offset, y_offset)

            # Quick collision check with tight tolerance for maximum density
            collision = False
            for placed_poly in placed_polygons:
                if check_collision(test_polygon, placed_poly.polygon, min_gap=10.0):
                    collision = True
                    break

            if not collision:
                return x, y

    return None, None


def find_bottom_left_position(
    polygon: Polygon, placed_polygons, sheet_width: float, sheet_height: float
):
    """FAST Simple bottom-left placement - prioritize speed over perfect density."""
    _Stats.call_counter += 1

    logger.debug(
        f"üîç find_bottom_left_position –≤—ã–∑–≤–∞–Ω–∞ –¥–ª—è –ø–æ–ª–∏–≥–æ–Ω–∞ —Å bounds={polygon.bounds}"
    )
    logger.debug(f"   –£–∂–µ —Ä–∞–∑–º–µ—â–µ–Ω–æ –∫–æ–≤—Ä–æ–≤: {len(placed_polygons)}")

    # First placement - always bottom-left corner
    if not placed_polygons:
        logger.debug("   ‚úì –ü–µ—Ä–≤—ã–π –∫–æ–≤—ë—Ä - —Ä–∞–∑–º–µ—â–∞–µ–º –≤ (0, 0)")
        return 0, 0

    bounds = polygon.bounds
    poly_width = bounds[2] - bounds[0]
    poly_height = bounds[3] - bounds[1]

    logger.debug(f"   –†–∞–∑–º–µ—Ä—ã –∫–æ–≤—Ä–∞: {poly_width:.1f} x {poly_height:.1f}")

    # FAST SCAN: Use large steps for speed
    step = max(10.0, min(poly_width, poly_height) / 3)  # Large adaptive step for speed

    best_y = None

    # –ö–†–ò–¢–ò–ß–ù–û: –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º X –ø–æ–∑–∏—Ü–∏–∏ –¥–ª—è –ú–ê–ö–°–ò–ú–ê–õ–¨–ù–û–ô –∫–æ–º–ø–∞–∫—Ç–Ω–æ—Å—Ç–∏
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º: 0 (–ª–µ–≤—ã–π –∫—Ä–∞–π), —Å–ø—Ä–∞–≤–∞ –æ—Ç –∫–∞–∂–¥–æ–≥–æ –∫–æ–≤—Ä–∞, –ø—Ä–∞–≤—ã–π –∫—Ä–∞–π
    x_positions = []

    # 1. –õ–µ–≤—ã–π –∫—Ä–∞–π
    x_positions.append(0)

    # 2. –ü–æ–∑–∏—Ü–∏–∏ —Å–ø—Ä–∞–≤–∞ –æ—Ç –∫–∞–∂–¥–æ–≥–æ —Ä–∞–∑–º–µ—â–µ–Ω–Ω–æ–≥–æ –∫–æ–≤—Ä–∞
    for placed_poly in placed_polygons:
        right_edge = placed_poly.polygon.bounds[2]
        if right_edge + poly_width <= sheet_width:
            x_positions.append(
                int(right_edge) + 10
            )  # –ò–°–ü–†–ê–í–õ–ï–ù–û: 10mm gap –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏ —Å check_collision

    # 3. –ü—Ä–∞–≤—ã–π –∫—Ä–∞–π –ª–∏—Å—Ç–∞ (–ø—Ä–∏–∂–∞—Ç—å –∫ –ø—Ä–∞–≤–æ–º—É –∫—Ä–∞—é!)
    right_aligned_x = int(sheet_width - poly_width)
    if right_aligned_x >= 0:
        x_positions.append(right_aligned_x)

    # 4. –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã–µ –ø–æ–∑–∏—Ü–∏–∏ –¥–ª—è –ø–æ–ª–Ω–æ—Ç—ã
    for x in range(0, int(sheet_width - poly_width), max(5, int(step))):
        x_positions.append(x)

    # –£–±–∏—Ä–∞–µ–º –¥—É–±–ª–∏–∫–∞—Ç—ã –∏ —Å–æ—Ä—Ç–∏—Ä—É–µ–º (–ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç –ª–µ–≤—ã–º)
    x_positions = sorted(set(x_positions))

    # OPTIMIZATION: Cache obstacles and STRtree ONCE
    obstacles = [placed_poly.polygon for placed_poly in placed_polygons]
    global _global_spatial_cache
    _global_spatial_cache.update(obstacles)

    # BATCH OPTIMIZATION: Collect ALL candidate positions first
    all_candidates = []  # (x, y, x_offset, y_offset)

    # –£–õ–£–ß–®–ï–ù–ò–ï –ü–õ–û–¢–ù–û–°–¢–ò: –ü—Ä–æ–≤–µ—Ä—è–µ–º –±–æ–ª—å—à–µ X –ø–æ–∑–∏—Ü–∏–π –¥–ª—è –ª—É—á—à–µ–π –∫–æ–º–ø–∞–∫—Ç–Ω–æ—Å—Ç–∏
    for test_x in x_positions[:30]:  # –£–≤–µ–ª–∏—á–µ–Ω–æ —Å 15 –¥–æ 30 –¥–ª—è –±–æ–ª—å—à–µ–π –ø–ª–æ—Ç–Ω–æ—Å—Ç–∏
        # Test only a few Y positions per X for speed
        test_y_positions = [0]  # Always try bottom

        # Add positions based on existing polygons - check ALL polygons for dense packing
        # –ö–†–ò–¢–ò–ß–ù–û –¥–ª—è –ø–ª–æ—Ç–Ω–æ—Å—Ç–∏: –Ω—É–∂–Ω–æ —É—á–∏—Ç—ã–≤–∞—Ç—å –í–°–ï —Ä–∞–∑–º–µ—â–µ–Ω–Ω—ã–µ –∫–æ–≤—Ä—ã
        for placed_poly in placed_polygons:  # –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤—Å–µ –ø–æ–ª–∏–≥–æ–Ω—ã
            other_bounds = placed_poly.polygon.bounds
            y_above = (
                other_bounds[3] + 10.0
            )  # –ò–°–ü–†–ê–í–õ–ï–ù–û: 10mm gap –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏ —Å check_collision
            test_y_positions.append(y_above)
            logger.debug(
                f"      –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º Y –ø–æ–∑–∏—Ü–∏—é –≤—ã—à–µ –∫–æ–≤—Ä–∞ {placed_poly.filename}: {other_bounds[3]:.1f} + 10.0 = {y_above:.1f}"
            )
            # –î–æ–±–∞–≤–ª—è–µ–º —Ç–∞–∫–∂–µ –ø–æ–∑–∏—Ü–∏–∏ —Å–ø—Ä–∞–≤–∞ –æ—Ç –∫–æ–≤—Ä–æ–≤ –¥–ª—è –ª—É—á—à–µ–π –∫–æ–º–ø–∞–∫—Ç–Ω–æ—Å—Ç–∏
            test_y_positions.append(other_bounds[1])  # –ù–∞ —Ç–æ–π –∂–µ –≤—ã—Å–æ—Ç–µ —á—Ç–æ –Ω–∏–∑
            test_y_positions.append(
                other_bounds[1] + (other_bounds[3] - other_bounds[1]) / 2
            )  # –ü–æ—Å–µ—Ä–µ–¥–∏–Ω–µ

        # Collect valid positions
        for test_y in sorted(set(test_y_positions)):
            if test_y < 0 or test_y + poly_height > sheet_height:
                continue

            x_offset = test_x - bounds[0]
            y_offset = test_y - bounds[1]

            # Quick bounds check
            test_bounds = (
                bounds[0] + x_offset,
                bounds[1] + y_offset,
                bounds[2] + x_offset,
                bounds[3] + y_offset,
            )

            if (
                test_bounds[0] >= 0
                and test_bounds[1] >= 0
                and test_bounds[2] <= sheet_width
                and test_bounds[3] <= sheet_height
            ):
                all_candidates.append((test_x, test_y, x_offset, y_offset))

    if not all_candidates:
        # Try fallback immediately if no candidates
        for y in range(0, int(sheet_height - poly_height), 20):
            for x in range(0, int(sheet_width - poly_width), 20):
                x_offset = x - bounds[0]
                y_offset = y - bounds[1]

                # –í–ê–ñ–ù–û: –ü—Ä–æ–≤–µ—Ä—è–µ–º –≥—Ä–∞–Ω–∏—Ü—ã –¥–ª—è fallback –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤!
                test_bounds = (
                    bounds[0] + x_offset,
                    bounds[1] + y_offset,
                    bounds[2] + x_offset,
                    bounds[3] + y_offset,
                )
                if (
                    test_bounds[0] >= 0
                    and test_bounds[1] >= 0
                    and test_bounds[2] <= sheet_width
                    and test_bounds[3] <= sheet_height
                ):
                    all_candidates.append((x, y, x_offset, y_offset))

                if len(all_candidates) >= 50:  # Limit fallback candidates
                    break
            if len(all_candidates) >= 50:
                break

    if not all_candidates:
        return None, None

    # BATCH: Create all translated polygons at once
    test_polygons = [
        translate_polygon(polygon, x_off, y_off)
        for _x, _y, x_off, y_off in all_candidates
    ]

    # BATCH: Check all collisions at once using fast batch check
    collisions = batch_check_collisions_cached_fast(
        test_polygons, _global_spatial_cache, min_gap=10.0
    )

    # –ö–†–ò–¢–ò–ß–ï–°–ö–û–ï –£–õ–£–ß–®–ï–ù–ò–ï: –í–º–µ—Å—Ç–æ –≤—ã–±–æ—Ä–∞ –ø–µ—Ä–≤–æ–π –ø–æ–∑–∏—Ü–∏–∏ —Å –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–º Y,
    # –æ—Ü–µ–Ω–∏–≤–∞–µ–º –í–°–ï –≤–∞–ª–∏–¥–Ω—ã–µ –ø–æ–∑–∏—Ü–∏–∏ –∏ –≤—ã–±–∏—Ä–∞–µ–º –ª—É—á—à—É—é –ø–æ –ø–ª–æ—Ç–Ω–æ—Å—Ç–∏

    valid_positions = []
    for i, has_collision in enumerate(collisions):
        if not has_collision:
            x, y, x_off, y_off = all_candidates[i]
            test_poly = test_polygons[i]

            # –û—Ü–µ–Ω–∏–≤–∞–µ–º –∫–∞—á–µ—Å—Ç–≤–æ –ø–æ–∑–∏—Ü–∏–∏ –¥–ª—è –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–π –ø–ª–æ—Ç–Ω–æ—Å—Ç–∏
            score = 0
            bounds = test_poly.bounds

            # 1. –ê–î–ê–ü–¢–ò–í–ù–´–ô –ü–†–ò–û–†–ò–¢–ï–¢ –ü–û–ó–ò–¶–ò–ò
            # –í–º–µ—Å—Ç–æ –∂—ë—Å—Ç–∫–æ–≥–æ —à—Ç—Ä–∞—Ñ–∞ –∑–∞ Y, –ø—Ä–∏–æ—Ä–∏—Ç–∏–∑–∏—Ä—É–µ–º –±–ª–∏–∑–æ—Å—Ç—å –∫ —Å–æ—Å–µ–¥—è–º
            # –≠—Ç–æ –ø–æ–∑–≤–æ–ª—è–µ—Ç —Ä–∞–∑–º–µ—â–∞—Ç—å –∫–æ–≤—Ä—ã –≤ –≤–µ—Ä—Ö–Ω–∏—Ö "–∫–∞—Ä–º–∞–Ω–∞—Ö" –µ—Å–ª–∏ –æ–Ω–∏ —Ç–∞–º —Ö–æ—Ä–æ—à–æ –ø–æ–º–µ—â–∞—é—Ç—Å—è

            # 1. –ü–†–ò–û–†–ò–¢–ï–¢: –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–æ–Ω—Ç–∞–∫—Ç–æ–≤ (—Å—Ç–µ–Ω–æ–∫) —Å —Å–æ—Å–µ–¥—è–º–∏ –∏ –≥—Ä–∞–Ω–∏—Ü–∞–º–∏
            # –ß–µ–º –±–æ–ª—å—à–µ –∫–æ–Ω—Ç–∞–∫—Ç–æ–≤, —Ç–µ–º –ø–ª–æ—Ç–Ω–µ–µ —É–ø–∞–∫–æ–≤–∫–∞
            contact_count = 0
            contact_bonus = 0

            # –°—á–∏—Ç–∞–µ–º –∫–æ–Ω—Ç–∞–∫—Ç—ã —Å —Å–æ—Å–µ–¥—è–º–∏ (–±–ª–∏–∑–æ—Å—Ç—å < 5–º–º = –∫–æ–Ω—Ç–∞–∫—Ç)
            for placed in placed_polygons:
                placed_bounds = placed.polygon.bounds

                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –±–ª–∏–∑–æ—Å—Ç—å —Å–æ –≤—Å–µ—Ö 4 —Å—Ç–æ—Ä–æ–Ω
                left_gap = bounds[0] - placed_bounds[2]  # –°–ª–µ–≤–∞ –æ—Ç placed
                right_gap = placed_bounds[0] - bounds[2]  # –°–ø—Ä–∞–≤–∞ –æ—Ç placed
                bottom_gap = bounds[1] - placed_bounds[3]  # –°–Ω–∏–∑—É –æ—Ç placed
                top_gap = placed_bounds[1] - bounds[3]  # –°–≤–µ—Ä—Ö—É –æ—Ç placed

                # –ö–æ–Ω—Ç–∞–∫—Ç –µ—Å–ª–∏ –∑–∞–∑–æ—Ä < 5–º–º
                if -5 < left_gap < 5:
                    contact_count += 1
                    contact_bonus -= 200000
                if -5 < right_gap < 5:
                    contact_count += 1
                    contact_bonus -= 200000
                if -5 < bottom_gap < 5:
                    contact_count += 1
                    contact_bonus -= 200000
                if -5 < top_gap < 5:
                    contact_count += 1
                    contact_bonus -= 200000

            # –ö–æ–Ω—Ç–∞–∫—Ç—ã —Å –≥—Ä–∞–Ω–∏—Ü–∞–º–∏ –ª–∏—Å—Ç–∞
            if bounds[0] < 5:  # –õ–µ–≤—ã–π –∫—Ä–∞–π
                contact_count += 1
                contact_bonus -= 100000
            if bounds[1] < 5:  # –ù–∏–∂–Ω–∏–π –∫—Ä–∞–π
                contact_count += 1
                contact_bonus -= 100000
            if abs(bounds[2] - sheet_width) < 5:  # –ü—Ä–∞–≤—ã–π –∫—Ä–∞–π
                contact_count += 1
                contact_bonus -= 100000
            if abs(bounds[3] - sheet_height) < 5:  # –í–µ—Ä—Ö–Ω–∏–π –∫—Ä–∞–π (—Ä–µ–∂–µ –Ω—É–∂–Ω–æ)
                contact_count += 1
                contact_bonus -= 50000

            score += contact_bonus

            # 2. –ú–ò–ù–ò–ú–ê–õ–¨–ù–´–ô —à—Ç—Ä–∞—Ñ –∑–∞ –≤—ã—Å–æ—Ç—É (–ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç –¥–ª—è –Ω–∏–∂–Ω–∏—Ö, –Ω–æ –Ω–µ –±–ª–æ–∫–∏—Ä—É—é—â–∏–π)
            score += y * 20

            # 3. –ú–ò–ù–ò–ú–ê–õ–¨–ù–´–ô —à—Ç—Ä–∞—Ñ –∑–∞ —É–¥–∞–ª—ë–Ω–Ω–æ—Å—Ç—å –æ—Ç –ª–µ–≤–æ–≥–æ –∫—Ä–∞—è
            score += bounds[0] * 5

            # 4. –ï—Å–ª–∏ –Ω–µ—Ç –∫–æ–Ω—Ç–∞–∫—Ç–æ–≤ –≤–æ–æ–±—â–µ, –±–æ–ª—å—à–æ–π —à—Ç—Ä–∞—Ñ (–∏–∑–æ–ª–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è)
            if contact_count == 0:
                score += 1000000  # –û—á–µ–Ω—å –ø–ª–æ—Ö–æ - –∫–æ–≤—ë—Ä –≤ –ø—É—Å—Ç–æ—Ç–µ

            # 5. –£–ú–ï–†–ï–ù–ù–´–ô –®–¢–†–ê–§ –ó–ê –ù–ï–î–û–°–¢–ê–¢–û–ß–ù–£–Æ –û–ü–û–†–£
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ–ø–æ—Ä—É —Å–Ω–∏–∑—É, –Ω–æ –Ω–µ –±–ª–æ–∫–∏—Ä—É–µ–º —Ä–∞–∑–º–µ—â–µ–Ω–∏–µ –≤ –≤–µ—Ä—Ö–Ω–∏—Ö –∫–∞—Ä–º–∞–Ω–∞—Ö
            bottom_y = bounds[1]
            if bottom_y > 50:
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ–ø–æ—Ä—É —Å–Ω–∏–∑—É
                support_area = 0
                for placed in placed_polygons:
                    if placed.polygon.bounds[3] <= bottom_y + 5:
                        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ —Å–Ω–∏–∑—É
                        support_test = translate_polygon(test_poly, 0, -3)
                        if support_test.intersects(placed.polygon):
                            intersection = support_test.intersection(placed.polygon)
                            support_area += intersection.area

                support_ratio = (
                    support_area / test_poly.area if test_poly.area > 0 else 0
                )

                # –ò–ó–ú–ï–ù–ï–ù–û: –£–º–µ—Ä–µ–Ω–Ω—ã–π —à—Ç—Ä–∞—Ñ –≤–º–µ—Å—Ç–æ –æ–≥—Ä–æ–º–Ω–æ–≥–æ
                # –ï—Å–ª–∏ –µ—Å—Ç—å –±–ª–∏–∑–∫–∏–µ —Å–æ—Å–µ–¥–∏, –æ–ø–æ—Ä–∞ –Ω–µ —Ç–∞–∫ –≤–∞–∂–Ω–∞
                if support_ratio < 0.4:
                    # –í–º–µ—Å—Ç–æ 100000, –∏—Å–ø–æ–ª—å–∑—É–µ–º 5000 - —É–º–µ—Ä–µ–Ω–Ω—ã–π —à—Ç—Ä–∞—Ñ
                    # –≠—Ç–æ –ø–æ–∑–≤–æ–ª—è–µ—Ç —Ä–∞–∑–º–µ—â–∞—Ç—å –∫–æ–≤—Ä—ã –≤ –≤–µ—Ä—Ö–Ω–∏—Ö –∫–∞—Ä–º–∞–Ω–∞—Ö
                    support_penalty = int((0.4 - support_ratio) * 5000)

                    # –ï—Å–ª–∏ –∫–æ–≤–µ—Ä –∏–º–µ–µ—Ç –º–Ω–æ–≥–æ –∫–æ–Ω—Ç–∞–∫—Ç–æ–≤ (–≤ –∫–∞—Ä–º–∞–Ω–µ), —É–º–µ–Ω—å—à–∞–µ–º —à—Ç—Ä–∞—Ñ
                    if contact_count >= 2:
                        support_penalty = support_penalty // 2

                    score += support_penalty

            valid_positions.append((score, x, y, i))

    # –í—ã–±–∏—Ä–∞–µ–º –ø–æ–∑–∏—Ü–∏—é —Å –ú–ò–ù–ò–ú–ê–õ–¨–ù–´–ú score (–ª—É—á—à–∞—è –ø–ª–æ—Ç–Ω–æ—Å—Ç—å)
    if valid_positions:
        valid_positions.sort()  # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ score
        best_score, best_x, best_y, best_i = valid_positions[0]

        logger.debug(f"   ‚úì –ù–∞–π–¥–µ–Ω–æ {len(valid_positions)} –≤–∞–ª–∏–¥–Ω—ã—Ö –ø–æ–∑–∏—Ü–∏–π")
        logger.debug(
            f"   ‚úì –í—ã–±—Ä–∞–Ω–∞ –ª—É—á—à–∞—è –ø–æ–∑–∏—Ü–∏—è: ({best_x:.1f}, {best_y:.1f}) —Å–æ score={best_score}"
        )
        if len(valid_positions) > 1:
            logger.debug(
                f"   –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤—ã (top 3): {[(score, x, y) for score, x, y, _ in valid_positions[:3]]}"
            )

        return best_x, best_y

    logger.warning(
        f"   ‚ùå –ù–ï –ù–ê–ô–î–ï–ù–û –≤–∞–ª–∏–¥–Ω—ã—Ö –ø–æ–∑–∏—Ü–∏–π! –í—Å–µ–≥–æ –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤: {len(all_candidates)}, –∫–æ–ª–ª–∏–∑–∏–π: {sum(collisions)}"
    )
    return None, None


def calculate_placement_waste(
    polygon: Polygon, placed_polygons: list[PlacedCarpet], sheet_width, sheet_height
):
    """Calculate waste/inefficiency for a polygon placement."""
    bounds = polygon.bounds

    # Calculate compactness - how close polygon is to other polygons and edges
    edge_distance = min(bounds[0], bounds[1])  # Distance to bottom-left corner

    # Distance to other polygons
    min_neighbor_distance = float("inf")
    for placed_tuple in placed_polygons:
        placed_polygon = placed_tuple.polygon
        placed_bounds = placed_polygon.bounds

        # Calculate minimum distance between bounding boxes
        dx = max(0, max(bounds[0] - placed_bounds[2], placed_bounds[0] - bounds[2]))
        dy = max(0, max(bounds[1] - placed_bounds[3], placed_bounds[1] - bounds[3]))
        distance = (dx**2 + dy**2) ** 0.5

        min_neighbor_distance = min(min_neighbor_distance, distance)

    if min_neighbor_distance == float("inf"):
        min_neighbor_distance = 0  # First polygon

    # Waste = edge_distance + average neighbor distance (lower is better)
    waste = edge_distance + min_neighbor_distance * 0.5
    return waste


def try_simple_placement(
    carpet: Carpet, existing_placed: list[PlacedCarpet], sheet_size: tuple[float, float]
) -> PlacedCarpet | None:
    """FAST placement using find_bottom_left_position for priority2 carpets."""
    import shapely.affinity

    # Convert sheet size from cm to mm
    sheet_width_mm, sheet_height_mm = sheet_size[0] * 10, sheet_size[1] * 10

    # Try all 4 rotations for better placement
    for angle in [0, 90, 180, 270]:
        rotated = get_cached_rotation(carpet, angle)
        bounds = rotated.bounds
        poly_width = bounds[2] - bounds[0]
        poly_height = bounds[3] - bounds[1]

        # Skip if doesn't fit
        if poly_width > sheet_width_mm or poly_height > sheet_height_mm:
            continue

        # Use find_bottom_left_position which intelligently checks edges and key positions
        bl_x, bl_y = find_bottom_left_position(
            rotated, existing_placed, sheet_width_mm, sheet_height_mm
        )

        if bl_x is not None and bl_y is not None:
            # Calculate final position
            dx = bl_x - bounds[0]
            dy = bl_y - bounds[1]
            positioned_polygon = shapely.affinity.translate(rotated, dx, dy)

            # Check if it fits in sheet
            pos_bounds = positioned_polygon.bounds
            if (
                pos_bounds[0] < 0
                or pos_bounds[1] < 0
                or pos_bounds[2] > sheet_width_mm
                or pos_bounds[3] > sheet_height_mm
            ):
                continue

            # Check for collisions with existing polygons
            has_collision = False
            for placed in existing_placed:
                if positioned_polygon.intersects(placed.polygon):
                    intersection = positioned_polygon.intersection(placed.polygon)
                    if hasattr(intersection, "area") and intersection.area > 0.1:
                        has_collision = True
                        break

            if not has_collision:
                # Found valid placement - return immediately
                return PlacedCarpet(
                    polygon=positioned_polygon,
                    x_offset=dx,
                    y_offset=dy,
                    angle=angle,
                    filename=carpet.filename,
                    color=carpet.color,
                    order_id=carpet.order_id,
                    carpet_id=carpet.carpet_id,
                    priority=carpet.priority,
                )

    return None  # No valid placement found


def bin_packing_with_inventory(
    carpets: list[Carpet],
    available_sheets: list[dict],
    verbose: bool = True,
    progress_callback=None,
) -> tuple[list[PlacedSheet], list[UnplacedCarpet]]:
    """Optimize placement of polygons on available sheets with inventory tracking.

    OPTIMIZED ALGORITHM: Maximum density packing with multi-pass optimization:
    1. Multi-pass bin packing with different sorting strategies
    2. Low-density sheet repacking optimization
    3. Inter-sheet optimization to minimize total sheets used
    4. Aggressive space utilization for client goals
    """
    logger.info(
        "=== –ù–ê–ß–ê–õ–û bin_packing_with_inventory (–ê–õ–ì–û–†–ò–¢–ú –ú–ê–ö–°–ò–ú–ê–õ–¨–ù–û–ô –ü–õ–û–¢–ù–û–°–¢–ò) ==="
    )
    if progress_callback:
        progress_callback(
            5,
            "–ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –∫–æ–≤—Ä–æ–≤ –∫ —Ä–∞—Å–∫–ª–∞–¥–∫–µ...",
        )

    clear_optimization_caches()

    # –í–ê–ñ–ù–û: –ö—ç—à–∏—Ä—É–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–µ –ø–æ–ª–∏–≥–æ–Ω—ã –î–û –ª—é–±—ã—Ö —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–π
    cache_original_polygons(carpets)

    placed_sheets: list[PlacedSheet] = []
    all_unplaced: list[UnplacedCarpet] = []
    sheet_inventory = [sheet.copy() for sheet in available_sheets]
    sheet_counter = 0

    # Step 1: Group carpets by priority
    logger.info("–ì—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞ –ø–æ–ª–∏–≥–æ–Ω–æ–≤ –ø–æ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç—É...")
    priority1_carpets: list[Carpet] = []  # Excel orders and additional priority 1
    priority2_carpets: list[Carpet] = []  # Priority 2 carpets

    for carpet in carpets:
        if carpet.priority == 2:
            priority2_carpets.append(carpet)
        else:
            # All Excel orders (ZAKAZ_*) and priority 1 items go together
            priority1_carpets.append(carpet)

    num_priority2_total = len(priority2_carpets)

    priority1_max_progress = 70 if priority2_carpets else 100

    logger.info(
        f"–ì—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞: {len(priority1_carpets)} –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç 1 + Excel, {len(priority2_carpets)} –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç 2"
    )

    # Early return if nothing to place
    if not priority1_carpets and not priority2_carpets:
        logger.info("–ù–µ—Ç –ø–æ–ª–∏–≥–æ–Ω–æ–≤ –¥–ª—è —Ä–∞–∑–º–µ—â–µ–Ω–∏—è")
        return placed_sheets, all_unplaced

    # STEP 2: Place priority 1 items (Excel orders + manual priority 1) with new sheets allowed
    logger.info(
        f"\n=== –≠–¢–ê–ü 2: –†–ê–ó–ú–ï–©–ï–ù–ò–ï {len(priority1_carpets)} –ü–†–ò–û–†–ò–¢–ï–¢ 1 + EXCEL –ó–ê–ö–ê–ó–û–í ==="
    )

    # Group priority 1 carpets by color for efficient processing
    remaining_priority1: list[Carpet] = list(priority1_carpets)

    for layout_idx, layout in enumerate(placed_sheets):
        if not remaining_priority1:
            break
        if (
            layout.usage_percent >= 95
        ):  # More aggressive filling - try harder to use existing sheets
            continue

        # Group remaining by color matching this sheet
        matching_carpets = [
            c for c in remaining_priority1 if c.color == layout.sheet_color
        ]
        if not matching_carpets:
            continue

        try:
            additional_placed, remaining_unplaced = bin_packing_with_existing(
                matching_carpets,
                layout.placed_polygons,
                layout.sheet_size,
                verbose=False,
            )

            if additional_placed:
                # Update layout
                placed_sheets[layout_idx].placed_polygons.extend(additional_placed)
                placed_sheets[layout_idx].usage_percent = calculate_usage_percent(
                    placed_sheets[layout_idx].placed_polygons, layout.sheet_size
                )

                # Update remaining
                remaining_carpet_map = {
                    UnplacedCarpet.from_carpet(c): c for c in matching_carpets
                }
                newly_remaining = set(
                    remaining_carpet_map[remaining_carpet]
                    for remaining_carpet in remaining_unplaced
                    if remaining_carpet in remaining_carpet_map
                )

                # Remove placed carpets from remaining list
                placed_carpet_set = set(
                    c for c in matching_carpets if c not in newly_remaining
                )
                remaining_priority1 = [
                    c for c in remaining_priority1 if c not in placed_carpet_set
                ]

                logger.info(
                    f"    –î–æ–∑–∞–ø–æ–ª–Ω–µ–Ω –ª–∏—Å—Ç #{layout.sheet_number}: +{len(additional_placed)} –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç1+Excel"
                )
        except Exception as e:
            logger.debug(f"–ù–µ —É–¥–∞–ª–æ—Å—å –¥–æ–∑–∞–ø–æ–ª–Ω–∏—Ç—å –ª–∏—Å—Ç –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–æ–º 1: {e}")
            continue

    # Create new sheets for remaining priority 1 carpets
    carpets_by_color: dict[str, list[Carpet]] = {}
    for carpet in remaining_priority1:
        color = carpet.color
        if color not in carpets_by_color:
            carpets_by_color[color] = []
        carpets_by_color[color].append(carpet)

    for color, color_carpets in carpets_by_color.items():
        remaining_carpets = list(color_carpets)

        # AGGRESSIVE RETRY: Try to place remaining carpets on ALL existing sheets before creating new ones
        if remaining_carpets and placed_sheets:
            logger.info(
                f"–ü–æ–ø—ã—Ç–∫–∞ –∞–≥—Ä–µ—Å—Å–∏–≤–Ω–æ–≥–æ –¥–æ–∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö –ª–∏—Å—Ç–æ–≤ –¥–ª—è {len(remaining_carpets)} –∫–æ–≤—Ä–æ–≤ {color}"
            )

            # Try each existing sheet again with more relaxed criteria
            for layout_idx, layout in enumerate(placed_sheets):
                if not remaining_carpets:
                    break

                # Only skip if truly full (>98%) or wrong color
                if layout.usage_percent >= 98 or layout.sheet_color != color:
                    continue

                # Try to fit remaining carpets on this sheet with more aggressive attempts
                matching_carpets = [c for c in remaining_carpets if c.color == color]
                if not matching_carpets:
                    continue

                try:
                    # Try multiple times with different carpet orderings for better fit
                    best_placed = []
                    best_remaining = matching_carpets
                    remaining_carpet_map = {
                        UnplacedCarpet.from_carpet(c): c for c in matching_carpets
                    }

                    for attempt in range(4):  # Try 4 different enhanced orderings
                        if attempt == 1:
                            # Enhanced big-to-small strategy (best for foundation)
                            def get_foundation_score(carpet: Carpet):
                                bounds = carpet.polygon.bounds
                                area = carpet.polygon.area
                                width = bounds[2] - bounds[0]
                                return (
                                    area * 1000 + width
                                )  # Prioritize large + wide shapes

                            test_carpets = sorted(
                                matching_carpets, key=get_foundation_score, reverse=True
                            )
                        elif attempt == 2:
                            # Small-to-large strategy (good for filling gaps)
                            test_carpets = sorted(
                                matching_carpets, key=lambda c: c.polygon.area
                            )
                        elif attempt == 3:
                            # Width-prioritized sorting (good for horizontal filling)
                            def get_width_score(carpet: Carpet):
                                bounds = carpet.polygon.bounds
                                width = bounds[2] - bounds[0]
                                area = carpet.polygon.area
                                return width * 1000 + area  # Width first, then area

                            test_carpets = sorted(
                                matching_carpets, key=get_width_score, reverse=True
                            )
                        else:
                            # Default order (original)
                            test_carpets = matching_carpets

                        additional_placed, remaining_unplaced = (
                            bin_packing_with_existing(
                                test_carpets,
                                layout.placed_polygons,
                                layout.sheet_size,
                                verbose=False,
                            )
                        )

                        # Keep the best result
                        if len(additional_placed) > len(best_placed):
                            best_placed = additional_placed
                            best_remaining = [
                                remaining_carpet_map.get(
                                    UnplacedCarpet(
                                        polygon=rt.polygon,
                                        carpet_id=rt.carpet_id,
                                        priority=rt.priority,
                                        filename=rt.filename,
                                        color=rt.color,
                                        order_id=rt.order_id,
                                    ),
                                    next(
                                        (
                                            c
                                            for c in matching_carpets
                                            if (
                                                c.polygon,
                                                c.filename,
                                                c.color,
                                                c.order_id,
                                            )
                                            == (
                                                rt.polygon,
                                                rt.filename,
                                                rt.color,
                                                rt.order_id,
                                            )
                                        ),
                                        None,
                                    ),
                                )
                                for rt in remaining_unplaced
                                if remaining_carpet_map.get(
                                    UnplacedCarpet(
                                        polygon=rt.polygon,
                                        carpet_id=rt.carpet_id,
                                        priority=rt.priority,
                                        filename=rt.filename,
                                        color=rt.color,
                                        order_id=rt.order_id,
                                    ),
                                    next(
                                        (
                                            c
                                            for c in matching_carpets
                                            if (
                                                c.polygon,
                                                c.filename,
                                                c.color,
                                                c.order_id,
                                            )
                                            == (
                                                rt.polygon,
                                                rt.filename,
                                                rt.color,
                                                rt.order_id,
                                            )
                                        ),
                                        None,
                                    ),
                                )
                                is not None
                            ]

                    # Apply the best result if any improvement
                    if best_placed:
                        # CRITICAL: Verify no overlaps before accepting placement
                        all_existing_polygons = (
                            p.polygon for p in layout.placed_polygons
                        )
                        new_polygons = (p.polygon for p in best_placed)

                        # Check for any overlaps between new and existing polygons
                        has_overlap = False
                        for new_poly in new_polygons:
                            for existing_poly in all_existing_polygons:
                                if check_collision(
                                    new_poly,
                                    existing_poly,
                                    min_gap=1.0,  # –£–≤–µ–ª–∏—á–∏–ª–∏ –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–π
                                ):
                                    logger.error(
                                        f"–ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –û–®–ò–ë–ö–ê: –û–±–Ω–∞—Ä—É–∂–µ–Ω–æ –ø–µ—Ä–µ–∫—Ä—ã—Ç–∏–µ –ø—Ä–∏ –∞–≥—Ä–µ—Å—Å–∏–≤–Ω–æ–º –¥–æ–∑–∞–ø–æ–ª–Ω–µ–Ω–∏–∏ –ª–∏—Å—Ç–∞ #{layout.sheet_number}"
                                    )
                                    has_overlap = True
                                    break
                            if has_overlap:
                                break

                        # Only accept if no overlaps detected
                        if not has_overlap:
                            # Update layout
                            placed_sheets[layout_idx].placed_polygons.extend(
                                best_placed
                            )
                            placed_sheets[
                                layout_idx
                            ].usage_percent = calculate_usage_percent(
                                placed_sheets[layout_idx].placed_polygons,
                                layout.sheet_size,
                            )
                        else:
                            logger.warning(
                                "–û—Ç–∫–ª–æ–Ω–µ–Ω–æ –∞–≥—Ä–µ—Å—Å–∏–≤–Ω–æ–µ –¥–æ–∑–∞–ø–æ–ª–Ω–µ–Ω–∏–µ –∏–∑-–∑–∞ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–Ω—ã—Ö –ø–µ—Ä–µ–∫—Ä—ã—Ç–∏–π"
                            )

                            # Remove successfully placed carpets from remaining list
                            placed_carpet_set = set(
                                c for c in matching_carpets if c not in best_remaining
                            )
                            remaining_carpets = [
                                c
                                for c in remaining_carpets
                                if c not in placed_carpet_set
                            ]

                except Exception as e:
                    logger.debug(f"–ù–µ —É–¥–∞–ª–æ—Å—å –∞–≥—Ä–µ—Å—Å–∏–≤–Ω–æ –¥–æ–∑–∞–ø–æ–ª–Ω–∏—Ç—å –ª–∏—Å—Ç: {e}")
                    continue

        while remaining_carpets:
            sheet_type = find_available_sheet_of_color(color, sheet_inventory)
            if not sheet_type:
                logger.warning(f"–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –ª–∏—Å—Ç–æ–≤ —Ü–≤–µ—Ç–∞ {color} –¥–ª—è –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–∞ 1")
                all_unplaced.extend(
                    UnplacedCarpet.from_carpet(carpet) for carpet in remaining_carpets
                )
                break

            sheet_counter += 1
            sheet_type["used"] += 1
            sheet_size = (sheet_type["width"], sheet_type["height"])

            ###################################################################
            # Keep original bin_packing for now to ensure stability
            t1 = time.time()
            placed, remaining = bin_packing(
                remaining_carpets,
                sheet_size,
                verbose=False,
                progress_callback=progress_callback,
            )
            logger.info(f"bin_packing —Å—Ä–∞–±–æ—Ç–∞–ª –∑–∞ {time.time() - t1} c.")

            if placed:
                new_layout = create_new_sheet(sheet_type, sheet_counter, color)
                new_layout.placed_polygons = placed
                new_layout.usage_percent = calculate_usage_percent(placed, sheet_size)
                new_layout.orders_on_sheet = list(
                    set(
                        carpet.order_id
                        for carpet in remaining_carpets
                        if carpet not in remaining
                    )
                )
                placed_sheets.append(new_layout)

                remaining_carpets = remaining
                logger.info(
                    f"    –°–æ–∑–¥–∞–Ω –ª–∏—Å—Ç #{sheet_counter}: {len(placed)} –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç1+Excel"
                )

                if progress_callback:
                    progress = min(
                        priority1_max_progress,
                        int(
                            priority1_max_progress * len(placed_sheets) / (len(carpets))
                        ),
                    )
                    progress_callback(
                        progress,
                        f"–°–æ–∑–¥–∞–Ω –ª–∏—Å—Ç #{sheet_counter}. –†–∞–∑–º–µ—â–µ–Ω–æ –∫–æ–≤—Ä–æ–≤: {len(placed)}",
                    )
            else:
                logger.warning(
                    f"–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞–∑–º–µ—Å—Ç–∏—Ç—å –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç 1 –Ω–∞ –Ω–æ–≤–æ–º –ª–∏—Å—Ç–µ {color}"
                )
                all_unplaced.extend(
                    UnplacedCarpet.from_carpet(carpet) for carpet in remaining_carpets
                )
                sheet_type["used"] -= 1
                sheet_counter -= 1
                break

    # STEP 3: Place priority 2 on remaining space only (no new sheets)
    logger.info(
        f"\n=== –≠–¢–ê–ü 3: –†–ê–ó–ú–ï–©–ï–ù–ò–ï {len(priority2_carpets)} –ü–†–ò–û–†–ò–¢–ï–¢2 –ù–ê –°–í–û–ë–û–î–ù–û–ú –ú–ï–°–¢–ï ==="
    )

    remaining_priority2: list[Carpet] = list(priority2_carpets)
    placed_sheets, all_unplaced = place_priority2(
        num_priority2_total,
        remaining_priority2,
        placed_sheets,
        all_unplaced,
        progress_callback,
    )

    # STEP 4: Sort sheets by color (group black together, then grey)
    logger.info("\n=== –≠–¢–ê–ü 7: –ì–†–£–ü–ü–ò–†–û–í–ö–ê –õ–ò–°–¢–û–í –ü–û –¶–í–ï–¢–ê–ú ===")

    # Separate black and grey sheets, maintain relative order within each color
    black_sheets = []
    grey_sheets = []

    for layout in placed_sheets:
        if layout.sheet_color == "—á—ë—Ä–Ω—ã–π":
            black_sheets.append(layout)
        else:
            grey_sheets.append(layout)

    # Reassign sheet numbers: first all black, then all grey
    final_layouts = []
    sheet_number = 1

    for layout in black_sheets + grey_sheets:
        layout.sheet_number = sheet_number
        final_layouts.append(layout)
        sheet_number += 1

    placed_sheets = final_layouts

    logger.info(
        f"–ü–µ—Ä–µ–≥—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞: {len(black_sheets)} —á–µ—Ä–Ω—ã—Ö + {len(grey_sheets)} —Å–µ—Ä—ã—Ö = {len(placed_sheets)} –ª–∏—Å—Ç–æ–≤"
    )

    # Final logging and progress
    logger.info("\n=== –ò–¢–û–ì–ò –†–ê–ó–ú–ï–©–ï–ù–ò–Ø ===")
    logger.info(f"–í—Å–µ–≥–æ –ª–∏—Å—Ç–æ–≤ —Å–æ–∑–¥–∞–Ω–æ: {len(placed_sheets)}")
    logger.info(f"–ù–µ—Ä–∞–∑–º–µ—â–µ–Ω–Ω—ã—Ö –ø–æ–ª–∏–≥–æ–Ω–æ–≤: {len(all_unplaced)}")

    if progress_callback:
        progress_callback(100, f"–ó–∞–≤–µ—Ä—à–µ–Ω–æ: {len(placed_sheets)} –ª–∏—Å—Ç–æ–≤ —Å–æ–∑–¥–∞–Ω–æ")

    return placed_sheets, all_unplaced


def calculate_usage_percent(
    placed_polygons: list[PlacedCarpet], sheet_size: tuple[float, float]
) -> float:
    """Calculate material usage percentage for a sheet."""
    used_area_mm2 = sum(placed_tuple.polygon.area for placed_tuple in placed_polygons)
    sheet_area_mm2 = (sheet_size[0] * 10) * (sheet_size[1] * 10)
    return (used_area_mm2 / sheet_area_mm2) * 100


def tighten_layout_with_obstacles(
    placed_to_move: list[PlacedCarpet],
    all_obstacles: list[PlacedCarpet],  # includes both existing and newly placed
    sheet_size=None,
    min_gap: float = 0.1,
    step: float = 1.0,
    max_passes: int = 3,
) -> list[PlacedCarpet]:
    """
    Improved tighten_layout that considers both new and existing obstacles.
    Only moves polygons in placed_to_move, checks collisions against all_obstacles.
    """
    if not placed_to_move:
        return placed_to_move

    # Create lists for manipulation
    movable_polys = [item.polygon for item in placed_to_move]
    all_obstacle_polys = [item.polygon for item in all_obstacles]
    meta = placed_to_move[:]

    n_movable = len(movable_polys)
    n_total = len(all_obstacle_polys)

    # Several passes to allow convergence
    for pass_idx in range(max_passes):
        moved_any = False

        for i in range(n_movable):
            poly = movable_polys[i]
            moved = poly

            # --- Move left step by step ---
            while True:
                test = translate_polygon(moved, -step, 0)
                # Check bounds
                if test.bounds[0] < -0.01:
                    break

                # Check collisions against ALL obstacles (existing + new)
                collision = False
                for j in range(n_total):
                    # Skip collision with self
                    if j < n_movable and j == i:
                        continue

                    other = all_obstacle_polys[j]
                    if check_collision(test, other, min_gap=min_gap):
                        collision = True
                        break

                if collision:
                    break

                # No collision - apply move
                moved = test
                moved_any = True

            # --- Move down step by step ---
            while True:
                test = translate_polygon(moved, 0, -step)
                if test.bounds[1] < -0.01:
                    break

                collision = False
                for j in range(n_total):
                    # Skip collision with self
                    if j < n_movable and j == i:
                        continue

                    other = all_obstacle_polys[j]
                    if check_collision(test, other, min_gap=min_gap):
                        collision = True
                        break

                if collision:
                    break

                moved = test
                moved_any = True

            # Update position
            movable_polys[i] = moved
            # Also update in the all_obstacles list for next iterations
            if i < n_movable:
                all_obstacle_polys[i] = moved

        # If no movement in this pass, stop
        if not moved_any:
            break

    # Create result list
    new_placed: list[PlacedCarpet] = []

    for i in range(n_movable):
        new_poly = movable_polys[i]
        orig_poly = placed_to_move[i].polygon

        # Calculate total displacement
        dx_total = new_poly.bounds[0] - orig_poly.bounds[0]
        dy_total = new_poly.bounds[1] - orig_poly.bounds[1]

        item = meta[i]
        new_x_off = item.x_offset + dx_total
        new_y_off = item.y_offset + dy_total

        new_placed.append(
            PlacedCarpet(
                polygon=new_poly,
                carpet_id=item.carpet_id,
                priority=item.priority,
                x_offset=new_x_off,
                y_offset=new_y_off,
                angle=item.angle,
                filename=item.filename,
                color=item.color,
                order_id=item.order_id,
            )
        )

    return new_placed


def tighten_layout(
    placed: list[PlacedCarpet],
    sheet_size=None,
    min_gap: float = 0.05,  # ULTRA-tight gap for maximum density
    step: float = 0.5,  # Finer step for better precision
    max_passes: int = 4,  # Reduced passes for better performance
) -> list[PlacedCarpet]:
    """
    –ñ–∞–¥–Ω—ã–π —Å–¥–≤–∏–≥ (greedy push): –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –ø–æ–ª–∏–≥–æ–Ω–∞ –ø—Ä–æ–±—É–µ–º —Å–¥–≤–∏–Ω—É—Ç—å –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ
    –≤–ª–µ–≤–æ, –∑–∞—Ç–µ–º –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –≤–Ω–∏–∑, –Ω–µ –Ω–∞—Ä—É—à–∞—è –∫–æ–ª–ª–∏–∑–∏–π —Å *–ª—é–±–æ–π* –¥—Ä—É–≥–æ–π –¥–µ—Ç–∞–ª—å—é.

    Args:
        placed: —Å–ø–∏—Å–æ–∫ –∫–æ—Ä—Ç–µ–∂–µ–π –ø–æ–ª–∏–≥–æ–Ω–æ–≤ –≤ –∞–±—Å–æ–ª—é—Ç–Ω—ã—Ö –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞—Ö.
                –§–æ—Ä–º–∞—Ç –∫–æ—Ä—Ç–µ–∂–∞ –æ–∂–∏–¥–∞–µ—Ç—Å—è –∫–∞–∫ –º–∏–Ω–∏–º—É–º (polygon, x_off, y_off, angle, filename, color, order_id)
                ‚Äî –Ω–æ —Ñ—É–Ω–∫—Ü–∏—è —Ä–∞–±–æ—Ç–∞–µ—Ç –∏ –µ—Å–ª–∏ —É –≤–∞—Å –Ω–µ–º–Ω–æ–≥–æ –¥—Ä—É–≥–æ–π –Ω–∞–±–æ—Ä –ø–æ–ª–µ–π: –æ–Ω–∞ –≤—Å–µ–≥–¥–∞
                –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç 7-—ç–ª–µ–º–µ–Ω—Ç–Ω—ã–π –∫–æ—Ä—Ç–µ–∂.
        sheet_size: –æ—Å—Ç–∞–≤–ª–µ–Ω –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏ —Å–∏–≥–Ω–∞—Ç—É—Ä (–Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –≤–Ω—É—Ç—Ä–∏).
        min_gap: –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –∑–∞–∑–æ—Ä –≤ –º–º (–ø–µ—Ä–µ–¥–∞–≤–∞–π—Ç–µ 0.0 –∏–ª–∏ 0.1).
        step: —à–∞–≥ —Å–¥–≤–∏–≥–∞ –≤ –º–º (1.0 ‚Äî —Ç–æ—á–Ω—ã–π, –º–æ–∂–Ω–æ –ø–æ—Å—Ç–∞–≤–∏—Ç—å 2.0 –¥–ª—è —É—Å–∫–æ—Ä–µ–Ω–∏—è).
        max_passes: —á–∏—Å–ª–æ –ø—Ä–æ—Ö–æ–¥–æ–≤ –ø–æ –≤—Å–µ–º –ø–æ–ª–∏–≥–æ–Ω–∞–º (–æ–±—ã—á–Ω–æ 2‚Äì3 –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ).
    Returns:
        –ù–æ–≤—ã–π —Å–ø–∏—Å–æ–∫ placed –≤ —Ç–æ–º –∂–µ —Ñ–æ—Ä–º–∞—Ç–µ (–∫–∞–∂–¥—ã–π —ç–ª–µ–º–µ–Ω—Ç ‚Äî 7-–∫–∞), –≥–¥–µ –ø–æ–ª–∏–≥–æ–Ω—ã —Å–¥–≤–∏–Ω—É—Ç—ã.
    """
    # –ó–∞—â–∏—Ç–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞
    if not placed:
        return placed

    # –°–æ–∑–¥–∞—ë–º —Å–ø–∏—Å–æ–∫ —Ç–µ–∫—É—â–∏—Ö –ø–æ–ª–∏–≥–æ–Ω–æ–≤ (–±—É–¥–µ–º –æ–±–Ω–æ–≤–ª—è—Ç—å)
    current_polys = [item.polygon for item in placed]
    meta = placed[:]

    n = len(current_polys)

    # ULTRA-AGGRESSIVE multi-directional tightening for maximum density
    for pass_idx in range(max_passes):
        moved_any = False

        # Try multiple tightening strategies in each pass
        strategies = [
            # Strategy 1: Bottom-left priority (traditional)
            [(-step, 0), (0, -step)],  # left, then down
            # Strategy 2: Top-right to bottom-left sweep
            [(0, -step), (-step, 0)],  # down, then left
            # Strategy 3: Diagonal micro-adjustments for ultra-tight packing
            [(-step / 2, -step / 2), (-step, 0), (0, -step)],  # diagonal, left, down
        ]

        # Use different strategy each pass for better convergence
        strategy = strategies[pass_idx % len(strategies)]

        # Process polygons in different orders for better optimization
        order_strategies = [
            range(n),  # Normal order
            range(n - 1, -1, -1),  # Reverse order
            sorted(range(n), key=lambda i: current_polys[i].bounds[1]),  # Bottom to top
            sorted(range(n), key=lambda i: current_polys[i].bounds[0]),  # Left to right
        ]

        process_order = order_strategies[pass_idx % len(order_strategies)]

        for i in process_order:
            poly = current_polys[i]
            moved = poly

            # Apply the selected strategy
            for dx, dy in strategy:
                # Keep moving in this direction until we hit something
                while True:
                    test = translate_polygon(moved, dx, dy)

                    # Check sheet boundaries with ultra-tight tolerance
                    if (
                        test.bounds[0] < -0.001
                        or test.bounds[1] < -0.001
                        or (sheet_size and test.bounds[2] > sheet_size[0] * 10 + 0.001)
                        or (sheet_size and test.bounds[3] > sheet_size[1] * 10 + 0.001)
                    ):
                        break

                    # Check collisions with all other polygons
                    collision = False
                    for j in range(n):
                        if j == i:
                            continue
                        other = current_polys[j]
                        # Ultra-tight collision check for maximum density
                        if check_collision(test, other, min_gap=min_gap):
                            collision = True
                            break

                    if collision:
                        break

                    # No collision - apply the move
                    moved = test
                    moved_any = True

                # Update current position after each direction
                current_polys[i] = moved

            # REVOLUTIONARY: Try "corner snapping" - move towards nearest corner/edge
            if pass_idx >= 2:  # Only in later passes when basic positioning is done
                # Calculate distances to edges
                bounds = moved.bounds

                # Try to snap to bottom edge
                if bounds[1] > step:
                    potential_y_move = -min(
                        bounds[1], step * 3
                    )  # Move up to 3 steps toward bottom
                    test = translate_polygon(moved, 0, potential_y_move)

                    if test.bounds[1] >= -0.001:  # Don't go below bottom
                        # Check if this position is collision-free
                        collision = False
                        for j in range(n):
                            if j == i:
                                continue
                            if check_collision(test, current_polys[j], min_gap=min_gap):
                                collision = True
                                break

                        if not collision:
                            moved = test
                            current_polys[i] = moved
                            moved_any = True

                # Try to snap to left edge
                if bounds[0] > step:
                    potential_x_move = -min(
                        bounds[0], step * 3
                    )  # Move up to 3 steps toward left
                    test = translate_polygon(moved, potential_x_move, 0)

                    if test.bounds[0] >= -0.001:  # Don't go beyond left edge
                        # Check if this position is collision-free
                        collision = False
                        for j in range(n):
                            if j == i:
                                continue
                            if check_collision(test, current_polys[j], min_gap=min_gap):
                                collision = True
                                break

                        if not collision:
                            moved = test
                            current_polys[i] = moved
                            moved_any = True

        # If no movement in this pass, stop early
        if not moved_any:
            break

    # –§–æ—Ä–º–∏—Ä—É–µ–º –Ω–æ–≤—ã–π —Å–ø–∏—Å–æ–∫ placed (–≤–æ–∑–≤—Ä–∞—â–∞–µ–º 7-—ç–ª–µ–º–µ–Ω—Ç–Ω—ã–µ –∫–æ—Ä—Ç–µ–∂–∏)
    new_placed: list[PlacedCarpet] = []

    for i in range(n):
        new_poly = current_polys[i]
        orig_poly = placed[i].polygon
        # –°–º–µ—â–µ–Ω–∏–µ –≤ –∞–±—Å–æ–ª—é—Ç–Ω—ã—Ö –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞—Ö –º–µ–∂–¥—É –∏—Å—Ö–æ–¥–Ω—ã–º –∏ –Ω–æ–≤—ã–º
        dx_total = new_poly.bounds[0] - orig_poly.bounds[0]
        dy_total = new_poly.bounds[1] - orig_poly.bounds[1]

        item = meta[i]
        new_x_off = item.x_offset + dx_total
        new_y_off = item.y_offset + dy_total

        new_placed.append(
            PlacedCarpet(
                polygon=new_poly,
                carpet_id=item.carpet_id,
                priority=item.priority,
                x_offset=new_x_off,
                y_offset=new_y_off,
                angle=item.angle,
                filename=item.filename,
                color=item.color,
                order_id=item.order_id,
            )
        )

    return new_placed


def place_priority2(
    num_priority2_total: int,
    remaining_priority2: list[Carpet],
    placed_layouts: list[PlacedSheet],
    all_unplaced: list[UnplacedCarpet],
    progress_callback=None,  # Callback function for progress updates
) -> tuple[list[PlacedSheet], list[UnplacedCarpet]]:
    # Sort layouts by increasing usage percent to fill emptier sheets first
    sorted_layouts = sorted(placed_layouts, key=lambda l: l.usage_percent)

    total_priority2_placed = 0

    for layout in sorted_layouts:
        if not remaining_priority2:
            break
        if layout.usage_percent >= 99:  # Skip almost full sheets
            continue

        # Get and sort matching carpets by decreasing area
        matching_carpets = sorted(
            [c for c in remaining_priority2 if c.color == layout.sheet_color],
            key=lambda c: c.polygon.area,
            reverse=True,
        )
        if not matching_carpets:
            logger.info(
                f"–õ–∏—Å—Ç #{layout.sheet_number}: –Ω–µ—Ç —Å–æ–≤–ø–∞–¥–∞—é—â–∏—Ö –∫–æ–≤—Ä–æ–≤ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–∞ 2 –ø–æ —Ü–≤–µ—Ç—É {layout.sheet_color}"
            )
            continue

        logger.info(
            f"–õ–∏—Å—Ç #{layout.sheet_number} ({layout.usage_percent:.1f}% –∑–∞–ø–æ–ª–Ω–µ–Ω): –ø—ã—Ç–∞–µ–º—Å—è —Ä–∞–∑–º–µ—Å—Ç–∏—Ç—å {len(matching_carpets)} –∫–æ–≤—Ä–æ–≤ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–∞ 2"
        )

        try:
            additional_placed = []
            current_placed = list(layout.placed_polygons)  # Copy current placements

            for carpet in matching_carpets:
                # Try simple placement for each carpet individually
                placed = try_simple_placement(carpet, current_placed, layout.sheet_size)
                if placed:
                    additional_placed.append(placed)
                    total_priority2_placed += 1
                    current_placed.append(placed)  # Update current for next placements
                    logger.info(f"  ‚úÖ –ö–æ–≤–µ—Ä {carpet.filename} —Ä–∞–∑–º–µ—â–µ–Ω —É—Å–ø–µ—à–Ω–æ")
                    if progress_callback:
                        progress = 70 + int(
                            100 * total_priority2_placed / num_priority2_total * 0.3
                        )
                        progress_callback(
                            progress,
                            f"–†–∞–∑–º–µ—â–µ–Ω–∏–µ –∫–æ–≤—Ä–æ–≤ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–∞ 2: {total_priority2_placed}/{num_priority2_total}",
                        )
                else:
                    logger.info(f"  ‚ùå –ö–æ–≤–µ—Ä {carpet.filename} –Ω–µ —Ä–∞–∑–º–µ—â–µ–Ω")

            if additional_placed:
                # Optimized overlap check - check only once per new item
                has_overlap = False
                existing_polygons = [p.polygon for p in layout.placed_polygons]

                for new in additional_placed:
                    # Use any() for early exit
                    overlapping_polys = [
                        existing
                        for existing in existing_polygons
                        if new.polygon.intersects(existing)
                    ]

                    if overlapping_polys:
                        # Check actual intersection area only for intersecting polygons
                        for existing in overlapping_polys:
                            inter = new.polygon.intersection(existing)
                            if hasattr(inter, "area") and inter.area > 1:
                                has_overlap = True
                                logger.warning(
                                    f"–ü–µ—Ä–µ–∫—Ä—ã—Ç–∏–µ –ø—Ä–∏ —Ä–∞–∑–º–µ—â–µ–Ω–∏–∏ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–∞ 2: {inter.area:.1f} –º–º¬≤ –Ω–∞ –ª–∏—Å—Ç–µ #{layout.sheet_number}"
                                )
                                break
                    if has_overlap:
                        break

                if not has_overlap:
                    # Update the layout
                    layout.placed_polygons.extend(additional_placed)
                    layout.usage_percent = calculate_usage_percent(
                        layout.placed_polygons, layout.sheet_size
                    )
                    # Remove placed carpets from remaining_priority2
                    placed_ids = set(
                        (p.filename, p.color, p.order_id) for p in additional_placed
                    )
                    remaining_priority2 = [
                        c
                        for c in remaining_priority2
                        if (c.filename, c.color, c.order_id) not in placed_ids
                    ]
                    logger.info(
                        f"    –î–æ–∑–∞–ø–æ–ª–Ω–µ–Ω –ª–∏—Å—Ç #{layout.sheet_number}: +{len(additional_placed)} –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç2, –æ—Å—Ç–∞–ª–æ—Å—å {len(remaining_priority2)}"
                    )
                else:
                    logger.warning(
                        f"–û—Ç–∫–ª–æ–Ω–µ–Ω–æ —Ä–∞–∑–º–µ—â–µ–Ω–∏–µ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–∞ 2 –∏–∑-–∑–∞ –ø–µ—Ä–µ–∫—Ä—ã—Ç–∏–π –Ω–∞ –ª–∏—Å—Ç–µ #{layout.sheet_number}"
                    )
        except Exception as e:
            logger.debug(f"–ù–µ —É–¥–∞–ª–æ—Å—å –¥–æ–∑–∞–ø–æ–ª–Ω–∏—Ç—å –ª–∏—Å—Ç –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–æ–º 2: {e}")
            continue

    # Add any remaining priority 2 to unplaced (no new sheets allowed for priority 2)
    if remaining_priority2:
        logger.info(
            f"–û—Å—Ç–∞–µ—Ç—Å—è –Ω–µ—Ä–∞–∑–º–µ—â–µ–Ω–Ω—ã–º–∏ {len(remaining_priority2)} –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç2 (–Ω–æ–≤—ã–µ –ª–∏—Å—Ç—ã –Ω–µ —Å–æ–∑–¥–∞—é—Ç—Å—è)"
        )
        all_unplaced.extend(
            UnplacedCarpet.from_carpet(carpet) for carpet in remaining_priority2
        )

    return placed_layouts, all_unplaced
